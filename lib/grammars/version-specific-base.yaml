---
name: mcfunction
scopeName: source.mcfunction
fileTypes:
  - mcfunction

names:
  # naming convention: <root_scope>._.<name>.<language>

  # error scopes
  invalid: invalid.illegal._.invalid.mcfunction
  underline: markup.underline._.underline.mcfunction

  # comment scopes
  comment: comment._.comment.mcfunction
  comment.heading: markup.heading._.heading.comment.mcfunction
  comment.marker.name: markup.bold._.name.marker.comment.mcfunction
  comment.marker.text: comment._.text.marker.comment.mcfunction
  comment.annotation.name: markup.heading._.name.annotation.comment.mcfunction
  comment.annotation.text: comment._.text.annotation.comment.mcfunction

  # command scopes
  command: keyword.control._.command.mcfunction
  subcommand: keyword.other._.subcommand.mcfunction

  # entity selector scopes
  entity_selector.base: support.class._.base.entity_selector.mcfunction
  entity_selector.bracket: support.class._.bracket.entity_selector.mcfunction
  entity_selector.equals: support.class._.equals.entity_selector.mcfunction
  entity_selector.comma: support.class._.comma.entity_selector.mcfunction
  entity_selector.not: constant.character.escape._.not.entity_selector.mcfunction
  entity_selector.param: keyword.other._.param.entity_selector.mcfunction

  # nbt scopes
  nbt.compound_bracket: storage._.compound_bracket.nbt.mcfunction
  nbt.compound_colon: storage._.compound_colon.nbt.mcfunction
  nbt.compound_comma: storage._.compound_comma.nbt.mcfunction
  nbt.list_bracket: storage._.list_bracket.nbt.mcfunction
  nbt.list_comma: storage._.list_comma.nbt.mcfunction

  # text component scopes
  text_component.compound_property: string._.property.text_component.mcfunction

  # scopes for other types of arguments accepted by `minecraft:entity`
  target.uuid: support.class._.uuid.target.mcfunction
  target.player_name: support.class._.player_name.target.mcfunction

  # string scopes
  string: string._.word.mcfunction
  string_escape: constant.character.escape._.word.mcfunction
  word: string._.word.mcfunction
  keyword: keyword._.keyword.mcfunction
  boolean: constant.numeric._.boolean.mcfunction

  # numeric scopes
  numeric_constant: constant.numeric._.numeric_constant.mcfunction

variables:
  # padding
  pad: " *"
  tpad: '[ \t]*'

  # lookahead_newline
  ln: '(?=\n)'

  # executable commands can be trailing
  # either consume a space or border a newline
  # command_border_executable_true
  cbx_true: '( |(?=\n))'

  # non-executable commands cannot be trailing
  # consume a space and also border something
  # still can give false positives for the command itself
  # but at least if the following token is also non-executable,
  # it will then be highlighted as an error
  # command_border_executable_false
  cbx_false: ' (?=[^\s\#])'

  # basic_entity_selector
  basic_entity_selector: '(\@[parse])'

  # parameterized_entity_selector
  parameterized_entity_selector.base: "{{basic_entity_selector}}"
  parameterized_entity_selector.args_l: '(\[)'
  parameterized_entity_selector.args_r: '(\])'
  parameterized_entity_selector.begin: "{{parameterized_entity_selector.base}}{{parameterized_entity_selector.args_l}}"
  parameterized_entity_selector.next: "{{parameterized_entity_selector.args_r}}"

  hex_digit: "[0-9a-fA-F]"
  uuid: "({{hex_digit}}+(?:(-){{hex_digit}}+){4})"

  boolean: "(true|false)"

  player_name: '(\w+)'

patterns:
  - include: "#comment"
  - include: "#command"
  - include: "#unknown"

capturesRepository:
  underlined_error:
    1:
      name: "#invalid"
    2:
      name: "#underline"

repository:
  comment:
    patterns:
      # comments begin on with `#`, after optional leading whitespace
      - name: meta._.comment.mcfunction
        begin: '^{{tpad}}(?=\#)'
        end: '\n'
        patterns:
          - include: "#comments"

  comments:
    patterns:
      - include: "#comment.heading"
      - include: "#comment.marker"
      - include: "#comment.annotation"
      - include: "#comment.other"

  comment.heading:
    # headers for separating blocks
    name: meta._.heading.comment.mcfunction
    match: "(##){{tpad}}(.*)$"
    captures:
      1:
        name: "#comment"
      2:
        name: "#comment.heading"

  comment.marker:
    # things that need attention, like todos and fixmes
    name: meta._.marker.comment.mcfunction
    match: '(#){{tpad}}((?:TODO|FIXME|XXX))(\b.*)$'
    captures:
      1:
        name: "#comment"
      2:
        name: "#comment.marker.name"
      3:
        name: "#comment.marker.text"

  comment.annotation:
    # doc tags like `@params` and `@returns`
    name: meta._.annotation.comment.mcfunction
    match: '(#){{tpad}}(\@\w*)(\b.*)$'
    captures:
      1:
        name: "#comment"
      2:
        name: "#comment.annotation.name"
      3:
        name: "#comment.annotation.text"

  comment.other:
    # any other comment should get caught here
    name: meta._.other.comment.mcfunction
    match: "(#.*)$"
    captures:
      1:
        name: "#comment"

  command:
    # commands begin with any non-whitespace, non-comment character, after optional leading whitespace
    name: meta._.command.mcfunction
    # don't start consuming the command yet
    begin: '^{{tpad}}(?=[^\s\#])'
    # we will actually consume the newline here
    # none of the sub-patterns will consume the newline
    # instead they will use lookahead to return to the parent scope
    end: '\n'
    patterns:
      - include: "#commands"

  commands:
    patterns:
      - include: "#generated.commands"

  unknown:
    # anything else gets caught here and highlighted as an error
    # in theory this should only ever happen for lines consisting entirely of whitespace
    name: meta._.unknown.mcfunction
    match: "^((.*))$"
    captures: "#underlined_error"

  ##############################################################################
  # ERRORS #####################################################################
  ##############################################################################

  error.unknown_string:
    # continue until the end of the string/line
    patterns:
      - match: '(([^\n\"]+))'
        captures: "#underlined_error"

  error.unknown_compound:
    # continue until the end of the compound/line
    patterns:
      - match: '(([^\n\}]+))'
        captures: "#underlined_error"

  error.unknown_list:
    # continue until the end of the list/line
    patterns:
      - match: '(([^\n\]]+))'
        captures: "#underlined_error"

  error.unknown_command:
    # continue until the end of the line
    name: meta._.unknown_command.mcfunction
    match: "((.*))$"
    captures: "#underlined_error"

  error.compound_value:
    # continue recursively until we see a separator or terminal
    # TODO how to assign multiple classes to content?
    patterns:
      - include: "#error.compound"
      - include: "#error.list"
      - match: '(([^\n\{\[\,\}]))'
        captures: "#underlined_error"

  error.compound:
    patterns:
      - begin: '((\{))'
        end: '((\}))'
        beginCaptures: "#underlined_error"
        endCaptures: "#underlined_error"
        contentName: "#invalid"
        patterns:
          - include: "#error.compound"
          - include: "#error.list"
          - match: '(([^\n\{\[\}]))'
            captures: "#underlined_error"

  error.list:
    patterns:
      - begin: '((\[))'
        end: '((\]))'
        beginCaptures: "#underlined_error"
        endCaptures: "#underlined_error"
        contentName: "#invalid"
        patterns:
          - include: "#error.compound"
          - include: "#error.list"
          - match: '(([^\n\{\[\]]))'
            captures: "#underlined_error"

  ##############################################################################
  # COMMON PARSERS #############################################################
  ##############################################################################

  common.double_quoted_string.content:
    patterns:
      # consume everything except for backslashes, double quotes, and newlines
      - match: '[^\\\"\n]'
        name: "#string"
      # consume any escaped characters... except for newlines
      - match: '\\[^\n]'
        name: "#string_escape"
      # consume a single backslash (implicitly followed by a newline) as an error
      - match: '((\\))'
        captures: "#underlined_error"
      # anything else (newlines and unescaped double quotes) will be handed back to the parent scope

  ##############################################################################
  # MINECRAFT PARSERS ##########################################################
  ##############################################################################

  minecraft.message:
    patterns:
      # pause when we see certain characters
      - match: '([^\@\n]+)'
        name: "#string"

      # check for selectors with arguments
      - begin: "{{parameterized_entity_selector.begin}}"
        end: "{{ln}}|{{parameterized_entity_selector.next}}"
        beginCaptures:
          1:
            name: "#entity_selector.base"
          2:
            name: "#entity_selector.bracket"
        endCaptures:
          1:
            name: "#entity_selector.bracket"
        patterns:
          - include: "#entity_selector.content"
          - include: "#error.unknown_command"

      # check for selectors without arguments
      - match: "{{basic_entity_selector}}"
        name: "#entity_selector.base"

      # catch characters that may have slipped through
      - match: '([^\n])'
        name: "#string"

  ##############################################################################
  # TEXT COMPONENTS ############################################################
  ##############################################################################

  # TODO can the text component schema be version-controlled?

  text_component:
    patterns:
      - include: "#text_component.boolean"
      - include: "#text_component.string"
      - include: "#text_component.list"
      - include: "#text_component.compound"

  text_component.boolean:
    patterns:
      - match: '(true|false)'
        name: '#boolean'

  text_component.string:
    patterns:
      - begin: '(\")'
        end: '{{ln}}|(\")'
        beginCaptures:
          1:
            name: "#string"
        endCaptures:
          1:
            name: "#string"
        patterns:
          - include: "#common.double_quoted_string.content"
          - include: "#error.unknown_string"

  text_component.list:
    patterns:
      - begin: '(\[)'
        end: '{{ln}}|(\])'
        beginCaptures:
          1:
            name: "#nbt.list_bracket"
        endCaptures:
          1:
            name: "#nbt.list_bracket"
        patterns:
          # NOTE how similar this is to selector arguments

          # consume commas between values
          - name: meta._.list.text_component.property_separator.mcfunction
            match: '(?<=[^\[\,])(\,)(?=[^\]\,])'
            captures:
              1:
                name: "#nbt.list_comma"

          # consume whitespace from separator to value
          - match: '(?<=[\[\,]) +(?=[^\]\,])'

          # consume whitespace from value to separator
          - match: '(?<=[^\[\,]) +(?=[\]\,])'

          # special case for empty lists, e.g. `[ ]`
          - match: '(?<=\[) +(?=\])'

          - include: "#text_component.list_values"

  text_component.list_values:
    patterns:
      - include: "#text_component"
      - include: "#error.unknown_list"

  text_component.compound:
    patterns:
      - begin: '(\{)'
        end: '{{ln}}|(\})'
        beginCaptures:
          1:
            name: "#nbt.compound_bracket"
        endCaptures:
          1:
            name: "#nbt.compound_bracket"
        patterns:
          # NOTE how similar this is to selector arguments

          # consume commas between properties
          - name: meta._.compound.text_component.property_separator.mcfunction
            match: '(?<=[^\{\,])(\,)(?=[^\}\,])'
            captures:
              1:
                name: "#nbt.compound_comma"

          # consume whitespace from separator to property
          - match: '(?<=[\{\,]) +(?=[^\}\,])'

          # consume whitespace from property to separator
          - match: '(?<=[^\{\,]) +(?=[\}\,])'

          # special case for empty compounds, e.g. `{ }`
          - match: '(?<=\{) +(?=\})'

          - include: "#text_component.compound_properties"

  text_component.compound_properties:
    patterns:
      # TODO implement remaining text component properties
      - include: "#text_component.compound_property.bold"
      - include: "#text_component.compound_property.text"
      - include: "#text_component.compound_property.selector"
      - include: "#text_component.compound_property.extra"
      - include: "#error.unknown_compound"

  text_component.compound_property.bold:
    # TODO this is actually worse now
    patterns:
      - begin: '(\")(bold)(\"){{pad}}(\:){{pad}}'
        end: '{{ln}}|(?={{pad}}[\,\}])'
        captures:
          1:
            name: "#string"
          2:
            name: "#text_component.compound_property"
          3:
            name: "#string"
          4:
            name: "#nbt.compound_colon"
        patterns:
          - include: "#text_component.boolean"
          - include: "#error.compound_value"

  text_component.compound_property.text:
    patterns:
      - begin: '(\")(text)(\"){{pad}}(\:){{pad}}(\")'
        end: '{{ln}}|(\")'
        beginCaptures:
          1:
            name: "#string"
          2:
            name: "#text_component.compound_property"
          3:
            name: "#string"
          4:
            name: "#nbt.compound_colon"
          5:
            name: "#string"
        endCaptures:
          1:
            name: "#string"
        patterns:
          - include: "#common.double_quoted_string.content"
          - include: "#error.unknown_string"

  text_component.compound_property.selector:
    patterns:
      - begin: '(\")(selector)(\"){{pad}}(\:){{pad}}(\")'
        end: '{{ln}}|(\")'
        beginCaptures:
          1:
            name: "#string"
          2:
            name: "#text_component.compound_property"
          3:
            name: "#string"
          4:
            name: "#nbt.compound_colon"
          5:
            name: "#string"
        endCaptures:
          1:
            name: "#string"
        patterns:
          # (1) selector without arguments
          - match: '{{basic_entity_selector}}(?=\")'
            name: "#entity_selector.base"

          # (2) uuid
          - match: '{{uuid}}(?=\")'
            name: "#target.uuid"

          # (3) player name
          - match: '{{player_name}}(?=\")'
            name: "#target.player_name"

          # (4) selector with arguments
          - begin: "{{parameterized_entity_selector.begin}}"
            end: '{{ln}}|(?=\")|{{parameterized_entity_selector.next}}'
            beginCaptures:
              1:
                name: "#entity_selector.base"
              2:
                name: "#entity_selector.bracket"
            endCaptures:
              1:
                name: "#entity_selector.bracket"
            patterns:
              - include: "#entity_selector.content"
              - include: "#error.unknown_string"

          - include: "#error.unknown_string"

  # TODO we should reorganize the others like this (local value highlight)
  text_component.compound_property.extra:
    patterns:
      - begin: '(\")(extra)(\"){{pad}}(\:){{pad}}'
        end: '{{ln}}|(?={{pad}}[\,\}])'
        captures:
          1:
            name: "#string"
          2:
            name: "#text_component.compound_property"
          3:
            name: "#string"
          4:
            name: "#nbt.compound_colon"
        patterns:
          - include: "#text_component.list"
          - include: "#error.compound_value"

  ##############################################################################
  # GENERATED COMMANDS #########################################################
  ##############################################################################

  generated.commands:
    # this is where the generator will inject command patterns
    patterns:
      - include: "#generated.command.say"
      - include: "#generated.command.tellraw"
      - include: "#generated.command.execute"
      - include: "#error.unknown_command"

  generated.command.say:
    begin: "(say){{cbx_false}}"
    end: "{{ln}}"
    beginCaptures:
      1:
        name: "#command"
    patterns:
      - include: "#generated.commands.say"

  generated.commands.say:
    patterns:
      - include: "#generated.command.say.message"
      - include: "#error.unknown_command"

  generated.command.say.message:
    # minecraft:message is an exception
    # it just consume the rest of the line, attempting to
    # parse various patterns (such as selectors) as it goes
    patterns:
      - include: "#minecraft.message"

  generated.command.tellraw:
    begin: "(tellraw){{cbx_false}}"
    end: "{{ln}}"
    beginCaptures:
      1:
        name: "#command"
    patterns:
      - include: "#generated.commands.tellraw"

  generated.commands.tellraw:
    patterns:
      - include: "#generated.command.tellraw.targets"
      - include: "#error.unknown_command"

  generated.command.tellraw.targets:
    # NOTE this should only allow players, but checking that via regex is not viable
    patterns:
      # (1) selector without arguments
      - begin: "{{basic_entity_selector}}{{cbx_false}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#entity_selector.base"
        patterns:
          - include: "#generated.commands.tellraw.targets"

      # (2) uuid
      - begin: "{{uuid}}{{cbx_false}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#target.uuid"
        patterns:
          - include: "#generated.commands.tellraw.targets"

      # (3) player name
      - begin: "{{player_name}}{{cbx_false}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#target.player_name"
        patterns:
          - include: "#generated.commands.tellraw.targets"

      # (4) selector with arguments
      - begin: "{{parameterized_entity_selector.begin}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#entity_selector.base"
          2:
            name: "#entity_selector.bracket"
        patterns:
          - begin: "{{parameterized_entity_selector.next}}{{cbx_false}}"
            end: "{{ln}}"
            beginCaptures:
              1:
                name: "#entity_selector.bracket"
            patterns:
              - include: "#generated.commands.tellraw.targets"
          - include: "#entity_selector.content"
          - include: "#error.unknown_command"

      - include: "#error.unknown_command"

  generated.commands.tellraw.targets:
    patterns:
      - include: "#text_component"
      - include: "#error.unknown_command"

  generated.command.execute:
    # `execute` is non-executable
    begin: "(execute){{cbx_false}}"
    end: "{{ln}}"
    beginCaptures:
      1:
        name: "#command"
    patterns:
      - include: "#generated.commands.execute"

  generated.commands.execute:
    # define child commands separately so they can be re-used in redirects
    patterns:
      - include: "#generated.command.execute.run"
      - include: "#generated.command.execute.as"
      - include: "#error.unknown_command"

  generated.command.execute.run:
    # `execute run` is executable
    begin: "(run){{cbx_true}}"
    end: "{{ln}}"
    beginCaptures:
      1:
        name: "#subcommand"
    patterns:
      - include: "#generated.commands.execute.run"

  generated.commands.execute.run:
    # redirect to root
    patterns:
      - include: "#generated.commands"

  generated.command.execute.as:
    # `execute as` is non-executable
    begin: "(as){{cbx_false}}"
    end: "{{ln}}"
    beginCaptures:
      1:
        name: "#subcommand"
    patterns:
      - include: "#generated.commands.execute.as"

  generated.commands.execute.as:
    patterns:
      - include: "#generated.command.execute.as.targets"
      - include: "#error.unknown_command"

  generated.command.execute.as.targets:
    # `execute as <targets>` is executable
    patterns:
      # unfortunately we cannot generalize these, because
      # we need to keep the context of the parent command

      # we can use basic `match` patterns for the simpler parsers (1-3)

      # (1) selector without arguments
      - begin: "{{basic_entity_selector}}{{cbx_true}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#entity_selector.base"
        patterns:
          - include: "#generated.commands.execute.as.targets"

      # (2) uuid
      - begin: "{{uuid}}{{cbx_true}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#target.uuid"
        patterns:
          - include: "#generated.commands.execute.as.targets"

      # (3) player name
      - begin: "{{player_name}}{{cbx_true}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#target.player_name"
        patterns:
          - include: "#generated.commands.execute.as.targets"

      # but more complex parsers will require further diving (4)

      # (4) selector with arguments
      - begin: "{{parameterized_entity_selector.begin}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#entity_selector.base"
          2:
            name: "#entity_selector.bracket"
        patterns:
          # the ending brace pattern cannot be generalized,
          # because it needs to return to a specific parent command
          - begin: "{{parameterized_entity_selector.next}}{{cbx_true}}"
            end: "{{ln}}"
            beginCaptures:
              1:
                name: "#entity_selector.bracket"
            patterns:
              # now we can finally resume back to the command arguments
              - include: "#generated.commands.execute.as.targets"

          # this is where common selector patterns can be included
          - include: "#entity_selector.content"

          # this doesn't go in common selector patterns, because it invalidates
          # rest of the line... which wouldn't make sense in other future
          # potential scopes, like text components
          - include: "#error.unknown_command"

      - include: "#error.unknown_command"

  generated.commands.execute.as.targets:
    # redirect to `execute`
    patterns:
      - include: "#generated.commands.execute"

  ##############################################################################
  # ENTITY SELECTORS ###########################################################
  ##############################################################################

  # TODO can selector arguments and their types be version-controlled?

  entity_selector.content:
    patterns:
      # consume commas between arguments
      - name: meta._.argument_separator.content.entity_selector.mcfunction
        match: '(?<=[^\[\,])(\,)(?=[^\]\,])'
        captures:
          1:
            name: "#entity_selector.comma"

      # consume whitespace from separator to argument
      - match: '(?<=[\[\,]) +(?=[^\]\,])'

      # consume whitespace from argument to separator
      - match: '(?<=[^\[\,]) +(?=[\]\,])'

      # special case for empty parameterized selectors, e.g. `@e[ ]`
      - match: '(?<=\[) +(?=\])'

      - include: "#entity_selector.arguments"

  entity_selector.arguments:
    # this is where the generator will inject selector argument patterns
    # but we'll need to write the data file for these by hand...
    patterns:
      - include: "#entity_selector.content.argument.tag"
      - include: "#entity_selector.content.argument.sort"
      - include: "#entity_selector.content.argument.limit"
      - include: "#entity_selector.content.argument.nbt"

  entity_selector.content.argument.tag:
    patterns:
      - name: meta._.tag.argument.content.entity_selector.mcfunction
        match: '(tag){{pad}}(\=){{pad}}(\!?){{pad}}(\w+){{pad}}(?=[\]\,])'
        captures:
          1:
            name: "#entity_selector.param"
          2:
            name: "#entity_selector.equals"
          3:
            name: "#entity_selector.not"
          4:
            name: "#word"

  entity_selector.content.argument.sort:
    patterns:
      - name: meta._.sort.argument.content.entity_selector.mcfunction
        match: '(sort){{pad}}(\=){{pad}}(arbitrary|furthest|nearest|random){{pad}}(?=[\]\,])'
        captures:
          1:
            name: "#entity_selector.param"
          2:
            name: "#entity_selector.equals"
          3:
            name: "#keyword"

  entity_selector.content.argument.limit:
    patterns:
      - name: meta._.limit.argument.content.entity_selector.mcfunction
        match: '(limit){{pad}}(\=){{pad}}(\d+){{pad}}(?=[\]\,])'
        captures:
          1:
            name: "#entity_selector.param"
          2:
            name: "#entity_selector.equals"
          3:
            name: "#numeric_constant"

  entity_selector.content.argument.nbt:
    patterns:
      - name: meta._.nbt.argument.content.entity_selector.mcfunction
        begin: '(nbt){{pad}}(\=){{pad}}(\!?){{pad}}(\{)'
        end: '{{ln}}|(\})'
        beginCaptures:
          1:
            name: "#entity_selector.param"
          2:
            name: "#entity_selector.equals"
          3:
            name: "#entity_selector.not"
          4:
            name: "#nbt.compound_bracket"
        endCaptures:
          1:
            name: "#nbt.compound_bracket"
        # TODO inner nbt patterns
        contentName: constant.character.escape
