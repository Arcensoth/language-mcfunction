---
name: mcfunction
scopeName: source.mcfunction
fileTypes:
  - mcfunction

names:
  # naming convention: <root_scope>._.<name>.<language>

  # error scopes
  invalid: invalid.illegal._.invalid.mcfunction
  underline: markup.underline._.underline.mcfunction

  # comment scopes
  comment: comment._.comment.mcfunction
  comment.heading: markup.heading._.heading.comment.mcfunction
  comment.marker.name: markup.bold._.name.marker.comment.mcfunction
  comment.marker.text: comment._.text.marker.comment.mcfunction
  comment.annotation.name: markup.heading._.name.annotation.comment.mcfunction
  comment.annotation.text: comment._.text.annotation.comment.mcfunction

  # command scopes
  command: keyword.control._.command.mcfunction
  subcommand: keyword.other._.subcommand.mcfunction
  command.slash: keyword.control._.command.mcfunction

  # target selector scopes
  target_selector.base: support.class._.base.target_selector.mcfunction
  target_selector.bracket: support.class._.bracket.target_selector.mcfunction
  target_selector.equals: support.class._.equals.target_selector.mcfunction
  target_selector.comma: support.class._.comma.target_selector.mcfunction
  target_selector.not: constant.character.escape._.not.target_selector.mcfunction
  target_selector.param: keyword.other._.param.target_selector.mcfunction

  # nbt scopes
  nbt.compound_bracket: storage._.compound_bracket.nbt.mcfunction
  nbt.compound_colon: storage._.compound_colon.nbt.mcfunction
  nbt.compound_comma: storage._.compound_comma.nbt.mcfunction
  nbt.list_bracket: storage._.list_bracket.nbt.mcfunction
  nbt.list_comma: storage._.list_comma.nbt.mcfunction

  # score map scopes
  score_map.bracket: storage._.bracket.score_map.mcfunction
  score_map.equals: storage._.equals.score_map.mcfunction
  score_map.comma: storage._.comma.score_map.mcfunction

  # advancement map scopes
  advancement_map.bracket: storage._.bracket.advancement_map.mcfunction
  advancement_map.equals: storage._.equals.advancement_map.mcfunction
  advancement_map.comma: storage._.comma.advancement_map.mcfunction

  # text component scopes
  text_component.bracket: storage._.bracket.text_component.mcfunction
  text_component.colon: storage._.colon.text_component.mcfunction
  text_component.comma: storage._.comma.text_component.mcfunction
  text_component.property: string._.property.text_component.mcfunction
  text_component.property.color: string._.color.property.text_component.mcfunction
  text_component.property.keybind: string._.keybind.property.text_component.mcfunction

  # resource location scopes
  resource_location.namespace: entity.name.function._.namespace.resource_location.mcfunction
  resource_location.hash: entity.name.function._.hash.resource_location.mcfunction
  resource_location.colon: entity.name.function._.colon.resource_location.mcfunction
  resource_location.path: entity.name.function._.path.resource_location.mcfunction

  # string scopes
  string: string._.string.mcfunction
  string_escape: constant.character.escape._.string_escape.mcfunction
  word: string._.word.mcfunction
  keyword: keyword._.keyword.mcfunction
  entity_tag: string._.entity_tag.mcfunction
  scoreboard_team: string._.scoreboard_team.mcfunction
  scoreboard_objective: string._.scoreboard_objective.mcfunction

  # numeric scopes
  number: constant.numeric._.number.mcfunction
  range.minimum: constant.numeric._.minimum.range.mcfunction
  range.maximum: constant.numeric._.maximum.range.mcfunction
  range.ellipsis: keyword.control._.ellipsis.range.mcfunction

  # scopes for other types of arguments accepted by `minecraft:entity`
  target.uuid: support.class._.uuid.target.mcfunction
  target.player_name: support.class._.player_name.target.mcfunction

  # other scopes
  generic.dict.bracket: storage._.bracket.dict.generic.mcfunction
  generic.dict.content: string._.content.dict.generic.mcfunction
  generic.list.bracket: storage._.bracket.list.generic.mcfunction
  generic.list.content: string._.content.list.generic.mcfunction
  boolean: constant.numeric._.boolean.mcfunction

variables:
  # padding
  pad: " *"
  tpad: '[ \t]*'

  # lookahead_newline
  ln: '(?=\n)'

  # executable commands can be trailing
  # either consume a space or border a newline
  # command_border_executable_true
  cbx_true: '( |(?=\n))'

  # non-executable commands cannot be trailing
  # consume a space and also border something
  # still can give false positives for the command itself
  # but at least if the following token is also non-executable,
  # it will then be highlighted as an error
  # command_border_executable_false
  cbx_false: ' (?=[^\s\#])'

  # text_component_property
  tc.p.begin_l: '(\")'
  tc.p.begin_r: '(\"){{pad}}(\:){{pad}}(?=[^\s\,\}])'
  tc.p.end: '{{ln}}|(?={{pad}}[\,\}])'

  # dictionary/compound
  dict.begin: '(\{)'
  dict.end: '{{ln}}|(\})'

  # list
  list.begin: '(\[)'
  list.end: '{{ln}}|(\])'

  # double_quoted_string
  dqs.begin: '(\")'
  dqs.end: '{{ln}}|(\")'

  # single_quoted_string
  sqs.begin: "(\\')"
  sqs.end: "{{ln}}|(\\')"

  # basic_target_selector
  basic_target_selector: '(\@[parse])'

  # parameterized_target_selector
  parameterized_target_selector.base: "{{basic_target_selector}}"
  parameterized_target_selector.args_l: '(\[)'
  parameterized_target_selector.args_r: '(\])'
  parameterized_target_selector.begin: '{{parameterized_target_selector.base}}{{parameterized_target_selector.args_l}}(?={{pad}}[\w\]])'
  parameterized_target_selector.next: "{{parameterized_target_selector.args_r}}"

  integer: '(\-?\d*)'
  positive_integer: '(0*[1-9]\d*)'
  double: '(\-?\d*\.?\d+)'

  boolean: "(true|false)"

  hex_digit: "[0-9a-fA-F]"
  uuid: "({{hex_digit}}+(?:(-){{hex_digit}}+){4})"

  player_name: '(\w+)'

  word: '([\w\.\-\+]+)'

  entity_tag: "{{word}}"
  scoreboard_team: "{{word}}"
  scoreboard_objective: "{{word}}"

  selector_gamemode_choices: "(survival|creative|adventure|spectator)"
  selector_sort_choices: "(arbitrary|furthest|nearest|random)"

  text_component.colors: (black|dark_blue|dark_green|dark_aqua|dark_red|dark_purple|gold|gray|dark_gray|blue|green|aqua|red|light_purple|yellow|white)
  text_component.keybinds: '(key\.forward|key\.left|key\.back|key\.right|key\.jump|key\.sneak|key\.sprint|key\.inventory|key\.swapHands|key\.drop|key\.use|key\.attack|key\.pickItem|key\.chat|key\.playerlist|key\.command|key\.screenshot|key\.togglePerspective|key\.smoothCamera|key\.fullscreen|key\.spectatorOutlines|key\.hotbar\.1|key\.hotbar\.2|key\.hotbar\.3|key\.hotbar\.4|key\.hotbar\.5|key\.hotbar\.6|key\.hotbar\.7|key\.hotbar\.8|key\.hotbar\.9|key\.saveToolbarActivator|key\.loadToolbarActivator)'

patterns:
  - include: "#comment"
  - include: "#command"
  - include: "#unknown"

capturesRepository:
  underlined_error:
    1:
      name: "#invalid"
    2:
      name: "#underline"

  quoted_string.begin:
    1:
      name: "#string"

  quoted_string.end:
    1:
      name: "#string"

  dict.begin:
    1:
      name: "#generic.dict.bracket"

  dict.end:
    1:
      name: "#generic.dict.bracket"

  list.begin:
    1:
      name: "#generic.list.bracket"

  list.end:
    1:
      name: "#generic.list.bracket"

  range:
    1:
      name: "#range.minimum"
    2:
      name: "#range.ellipsis"
    3:
      name: "#range.maximum"

  text_component.property:
    1:
      name: "#string"
    2:
      name: "#text_component.property"
    3:
      name: "#string"
    4:
      name: "#nbt.compound_colon"

  text_component.dict.begin:
    1:
      name: "#text_component.bracket"

  text_component.dict.end:
    1:
      name: "#text_component.bracket"

  text_component.list.begin:
    1:
      name: "#text_component.bracket"

  text_component.list.end:
    1:
      name: "#text_component.bracket"

repository:
  comment:
    patterns:
      # comments begin on with `#`, after optional leading whitespace
      - name: meta._.comment.mcfunction
        begin: '^{{tpad}}(?=\#)'
        end: '\n'
        patterns:
          - include: "#comments"

  comments:
    patterns:
      - include: "#comment.heading"
      - include: "#comment.marker"
      - include: "#comment.annotation"
      - include: "#comment.other"

  comment.heading:
    # headers for separating blocks
    name: meta._.heading.comment.mcfunction
    match: "(##){{tpad}}(.*)$"
    captures:
      1:
        name: "#comment"
      2:
        name: "#comment.heading"

  comment.marker:
    # things that need attention, like todos and fixmes
    name: meta._.marker.comment.mcfunction
    match: '(#){{tpad}}((?:TODO|FIXME|XXX))(\b.*)$'
    captures:
      1:
        name: "#comment"
      2:
        name: "#comment.marker.name"
      3:
        name: "#comment.marker.text"

  comment.annotation:
    # doc tags like `@params` and `@returns`
    name: meta._.annotation.comment.mcfunction
    match: '(#){{tpad}}(\@\w*)(\b.*)$'
    captures:
      1:
        name: "#comment"
      2:
        name: "#comment.annotation.name"
      3:
        name: "#comment.annotation.text"

  comment.other:
    # any other comment should get caught here
    name: meta._.other.comment.mcfunction
    match: "(#.*)$"
    captures:
      1:
        name: "#comment"

  command:
    # commands begin with any non-whitespace, non-comment character, after optional leading whitespace
    name: meta._.command.mcfunction
    # don't start consuming the command yet
    begin: '^{{tpad}}(?=[^\s\#])'
    # we will actually consume the newline here
    # none of the sub-patterns will consume the newline
    # instead they will use lookahead to return to the parent scope
    end: '\n'
    patterns:
      - include: "#commands"

  commands:
    patterns:
      - include: "#generated.commands"

  unknown:
    # anything else gets caught here and highlighted as an error
    # in theory this should only ever happen for lines consisting entirely of whitespace
    name: meta._.unknown.mcfunction
    match: "^((.*))$"
    captures: "#underlined_error"

  ##############################################################################
  # ERRORS #####################################################################
  ##############################################################################

  error.command_line:
    # continue until the end of the line
    name: meta._.unknown_command.mcfunction
    match: "((.*))$"
    captures: "#underlined_error"

  error.compound_value:
    # continue recursively until we see a separator or terminal
    patterns:
      - include: "#error.block_value"
      - match: '(([^\n\}\,]))'
        captures: "#underlined_error"

  error.list_value:
    patterns:
      - include: "#error.block_value"
      - match: '(([^\n\]\,]))'
        captures: "#underlined_error"

  error.block_value:
    patterns:
      - include: "#error.dict"
      - include: "#error.list"
      - include: "#error.quoted_string"

  error.block:
    patterns:
      - match: "(([^\\n\\{\\}\\[\\]\\\"\\']+))"
        captures: "#underlined_error"
      - include: "#error.block_value"

  error.dict:
    patterns:
      - begin: "({{dict.begin}})"
        end: "({{dict.end}})"
        beginCaptures: "#underlined_error"
        endCaptures: "#underlined_error"
        patterns:
          - include: "#error.block"

  error.list:
    patterns:
      - begin: "({{list.begin}})"
        end: "({{list.end}})"
        beginCaptures: "#underlined_error"
        endCaptures: "#underlined_error"
        patterns:
          - include: "#error.block"

  error.quoted_string:
    patterns:
      - include: "#error.double_quoted_string"
      - include: "#error.single_quoted_string"

  error.double_quoted_string:
    patterns:
      - begin: "({{dqs.begin}})"
        end: "({{dqs.end}})"
        beginCaptures: "#underlined_error"
        endCaptures: "#underlined_error"
        patterns:
          - include: "#error.double_quoted_string.content"

  error.single_quoted_string:
    patterns:
      - begin: "({{sqs.begin}})"
        end: "({{sqs.end}})"
        beginCaptures: "#underlined_error"
        endCaptures: "#underlined_error"
        patterns:
          - include: "#error.single_quoted_string.content"

  error.double_quoted_string.content:
    patterns:
      - match: '(([^\\\"\n]))'
        captures: "#underlined_error"
      - match: '((\\[^\n]))'
        captures: "#underlined_error"
      - match: '((\\))'
        captures: "#underlined_error"

  error.single_quoted_string.content:
    patterns:
      - match: "(([^\\\\\\'\\n]))"
        captures: "#underlined_error"
      - match: '((\\[^\n]))'
        captures: "#underlined_error"
      - match: '((\\))'
        captures: "#underlined_error"

  ##############################################################################
  # COMMON PARSERS #############################################################
  ##############################################################################

  common.block:
    patterns:
      - match: "[^\\n\\{\\}\\[\\]\\\"\\']+"
        name: "#generic.dict.content"
      - include: "#common.dict"
      - include: "#common.list"
      - include: "#common.quoted_string"

  common.dict:
    patterns:
      - begin: "{{dict.begin}}"
        end: "{{dict.end}}"
        beginCaptures: "#dict.begin"
        endCaptures: "#dict.end"
        patterns:
          - include: "#common.block"

  common.list:
    patterns:
      - begin: "{{list.begin}}"
        end: "{{list.end}}"
        beginCaptures: "#list.begin"
        endCaptures: "#list.end"
        patterns:
          - include: "#common.block"

  common.dict.whitespace:
    patterns:
      # consume commas between key-values
      # - match: '(?<=[^\{\,])(\,)(?=[^\}\,])'
      #   captures:
      #     1:
      #       name: "#dict.comma"

      # consume whitespace from separator to key
      - match: '(?<=[\{\,]) +(?=[^\}\,])'

      # consume whitespace from value to separator
      - match: '(?<=[^\{\,]) +(?=[\}\,])'

      # special case for empty dicts, e.g. `{ }`
      - match: '(?<=\{) +(?=\})'

  common.list.whitespace:
    patterns:
      # consume commas between values
      # - match: '(?<=[^\[\,])(\,)(?=[^\]\,])'
      #   captures:
      #     1:
      #       name: "#list.comma"

      # consume whitespace from separator to value
      - match: '(?<=[\[\,]) +(?=[^\]\,])'

      # consume whitespace from value to separator
      - match: '(?<=[^\[\,]) +(?=[\]\,])'

      # special case for empty lists, e.g. `[ ]`
      - match: '(?<=\[) +(?=\])'

  common.boolean:
    patterns:
      - match: '(?<!\w){{boolean}}(?!\w)'
        name: "#boolean"

  common.unquoted_string:
    patterns:
      - match: "{{word}}"
        name: "#word"

  common.double_quoted_string:
    patterns:
      - begin: "{{dqs.begin}}"
        end: "{{dqs.end}}"
        beginCaptures: "#quoted_string.begin"
        endCaptures: "#quoted_string.end"
        patterns:
          - include: "#common.double_quoted_string.content"

  common.single_quoted_string:
    patterns:
      - begin: "{{sqs.begin}}"
        end: "{{sqs.end}}"
        beginCaptures: "#quoted_string.begin"
        endCaptures: "#quoted_string.end"
        patterns:
          - include: "#common.single_quoted_string.content"

  common.double_quoted_string.content:
    patterns:
      # consume everything except for backslashes, double quotes, and newlines
      - match: '[^\\\"\n]'
        name: "#string"
      # consume any escaped characters... except for newlines
      - match: '\\[^\n]'
        name: "#string_escape"
      # consume a single backslash (implicitly followed by a newline) as an error
      - match: '((\\))'
        captures: "#underlined_error"
      # anything else (newlines and unescaped double quotes) will be handed back to the parent scope

  common.single_quoted_string.content:
    patterns:
      - match: "[^\\\\\\'\\n]"
        name: "#string"
      - match: '\\[^\n]'
        name: "#string_escape"
      - match: '((\\))'
        captures: "#underlined_error"

  common.quoted_string:
    patterns:
      - include: "#common.double_quoted_string"
      - include: "#common.single_quoted_string"

  common.quotable_string:
    patterns:
      - include: "#common.quoted_string"
      - include: "#common.unquoted_string"

  common.integer_range:
    patterns:
      # right-side optional
      - match: '{{integer}}(\.\.){{integer}}?'
        captures: "#range"
      # left-side optional
      - match: '{{integer}}?(\.\.){{integer}}'
        captures: "#range"
      # exact number
      - match: "{{integer}}"
        name: "#number"
      # elevate `..` and any other cases to parent

  common.double_range:
    patterns:
      # right-side optional
      - match: '{{double}}(\.\.){{double}}?'
        captures: "#range"
      # left-side optional
      - match: '{{double}}?(\.\.){{double}}'
        captures: "#range"
      # exact number
      - match: "{{double}}"
        name: "#number"
      # elevate `..` and any other cases to parent

  common.resource_location:
    # TODO refine resource location patterns
    patterns:
      - match: '([a-z0-9_\.\-]+)?(\:)?([a-z0-9_\.\-\/]+)'
        captures:
          1:
            name: "#resource_location.namespace"
          2:
            name: "#resource_location.colon"
          3:
            name: "#resource_location.path"

  common.tagged_resource_location:
    # TODO refine tagged resource location patterns
    patterns:
      - match: '(\#)([a-z0-9_\.\-]+)?(\:)?([a-z0-9_\.\-\/]+)'
        captures:
          1:
            name: "#resource_location.hash"
          2:
            name: "#resource_location.namespace"
          3:
            name: "#resource_location.colon"
          4:
            name: "#resource_location.path"

  common.taggable_resource_location:
    patterns:
      - include: "#common.tagged_resource_location"
      - include: "#common.resource_location"

  common.message:
    patterns:
      # pause when we see certain characters
      - match: '([^\@\n]+)'
        name: "#string"

      # check for selectors with arguments
      - begin: "{{parameterized_target_selector.begin}}"
        end: "{{ln}}|{{parameterized_target_selector.next}}"
        beginCaptures:
          1:
            name: "#target_selector.base"
          2:
            name: "#target_selector.bracket"
        endCaptures:
          1:
            name: "#target_selector.bracket"
        patterns:
          - include: "#target_selector.content"
          - include: "#error.command_line"

      # check for selectors without arguments
      - match: "{{basic_target_selector}}"
        name: "#target_selector.base"

      # catch characters that may have slipped through
      - match: '([^\n])'
        name: "#string"

  ##############################################################################
  # NBT ########################################################################
  ##############################################################################

  nbt.compound.content:
    # FIXME nbt compound patterns
    patterns:
      - include: "#common.block"

  ##############################################################################
  # MAPS #######################################################################
  ##############################################################################

  score_map.content:
    # FIXME score map patterns
    patterns:
      - include: "#common.block"

  advancement_map.content:
    # FIXME advancement map patterns
    patterns:
      - include: "#common.block"

  ##############################################################################
  # TEXT COMPONENTS ############################################################
  ##############################################################################

  # TODO consider version-controlling and generating text component properties
  # we could do this based on a json schema

  text_component:
    patterns:
      - include: "#text_component.boolean"
      - include: "#text_component.string"
      - include: "#text_component.list"
      - include: "#text_component.dict"

  text_component.boolean:
    - include: "#common.boolean"

  text_component.string:
    patterns:
      - include: "#common.double_quoted_string"

  text_component.string.color:
    patterns:
      - begin: "{{dqs.begin}}"
        end: "{{dqs.end}}"
        beginCaptures: "#quoted_string.begin"
        endCaptures: "#quoted_string.end"
        patterns:
          - match: "{{text_component.colors}}"
            name: "#text_component.property.color"
          - include: "#error.double_quoted_string.content"

  text_component.string.keybind:
    patterns:
      - begin: "{{dqs.begin}}"
        end: "{{dqs.end}}"
        beginCaptures: "#quoted_string.begin"
        endCaptures: "#quoted_string.end"
        patterns:
          - match: "{{text_component.keybinds}}"
            name: "#text_component.property.keybind"
          - include: "#error.double_quoted_string.content"

  text_component.string.insertion:
    patterns:
      - begin: '{{dqs.begin}}(\/)'
        end: "{{dqs.end}}"
        beginCaptures:
          1:
            name: "#string"
          2:
            name: "#command.slash"
        endCaptures: "#quoted_string.end"
        patterns:
          # TODO local error highlighting for commands
          - include: "#commands"
      - include: "#common.double_quoted_string"

  text_component.string.selector:
    patterns:
      - begin: "{{dqs.begin}}"
        end: "{{dqs.end}}"
        beginCaptures: "#quoted_string.begin"
        endCaptures: "#quoted_string.end"
        patterns:
          - include: "#text_component.string.selector.content"
          - include: "#error.double_quoted_string.content"

  text_component.string.selector.content:
    patterns:
      # (1) selector without arguments
      - match: '(?<=\"){{basic_target_selector}}(?=\")'
        name: "#target_selector.base"

      # (2) uuid
      - match: '(?<=\"){{uuid}}(?=\")'
        name: "#target.uuid"

      # (3) player name
      - match: '(?<=\"){{player_name}}(?=\")'
        name: "#target.player_name"

      # (4) selector with arguments
      - begin: '(?<=\"){{parameterized_target_selector.begin}}'
        end: '{{ln}}|(?=\")|{{parameterized_target_selector.next}}(?=\")'
        beginCaptures:
          1:
            name: "#target_selector.base"
          2:
            name: "#target_selector.bracket"
        endCaptures:
          1:
            name: "#target_selector.bracket"
        patterns:
          - include: "#target_selector.content"
          - include: "#error.double_quoted_string.content"

  text_component.list_common:
    patterns:
      # consume commas between values
      - match: '(?<=[^\[\,])(\,)(?=[^\]\,])'
        captures:
          1:
            name: "#text_component.comma"
      # consume whitespace
      - include: "#common.list.whitespace"

  text_component.list:
    patterns:
      - begin: "{{list.begin}}"
        end: "{{list.end}}"
        beginCaptures: "#text_component.list.begin"
        endCaptures: "#text_component.list.end"
        patterns:
          - include: "#text_component.list_common"
          - include: "#text_component.list_values"

  text_component.list_values:
    patterns:
      - include: "#text_component"
      - include: "#error.list_value"

  text_component.dict_common:
    patterns:
      # consume commas between key-values
      - match: '(?<=[^\{\,])(\,)(?=[^\}\,])'
        captures:
          1:
            name: "#text_component.comma"
      # consume whitespace
      - include: "#common.dict.whitespace"

  text_component.dict:
    patterns:
      - begin: "{{dict.begin}}"
        end: "{{dict.end}}"
        beginCaptures: "#text_component.dict.begin"
        endCaptures: "#text_component.dict.end"
        patterns:
          - include: "#text_component.dict_common"
          - include: "#text_component.properties"

  text_component.dict.score:
    patterns:
      - begin: "{{dict.begin}}"
        end: "{{dict.end}}"
        beginCaptures: "#text_component.dict.begin"
        endCaptures: "#text_component.dict.end"
        patterns:
          - include: "#text_component.dict_common"
          - include: "#text_component.properties.score"

  text_component.dict.clickEvent:
    patterns:
      - begin: "{{dict.begin}}"
        end: "{{dict.end}}"
        beginCaptures: "#text_component.dict.begin"
        endCaptures: "#text_component.dict.end"
        patterns:
          - include: "#text_component.dict_common"
          - include: "#text_component.properties.clickEvent"

  text_component.dict.hoverEvent:
    patterns:
      - begin: "{{dict.begin}}"
        end: "{{dict.end}}"
        beginCaptures: "#text_component.dict.begin"
        endCaptures: "#text_component.dict.end"
        patterns:
          - include: "#text_component.dict_common"
          - include: "#text_component.properties.hoverEvent"

  text_component.properties:
    patterns:
      - include: "#text_component.property.b_i_u_s_o"
      - include: "#text_component.property.color"
      - include: "#text_component.property.text_translate"
      - include: "#text_component.property.extra_with"
      - include: "#text_component.property.selector"
      - include: "#text_component.property.score"
      - include: "#text_component.property.keybind"
      - include: "#text_component.property.insertion"
      - include: "#text_component.property.clickEvent"
      - include: "#text_component.property.hoverEvent"
      - include: "#error.compound_value"

  text_component.property.b_i_u_s_o:
    patterns:
      - begin: "{{tc.p.begin_l}}(bold|italic|underlined|strikethrough|obfuscated){{tc.p.begin_r}}"
        end: "{{tc.p.end}}"
        beginCaptures: "#text_component.property"
        patterns:
          - include: "#text_component.boolean"
          - include: "#error.compound_value"

  text_component.property.text_translate:
    patterns:
      - begin: "{{tc.p.begin_l}}(text|translate){{tc.p.begin_r}}"
        end: "{{tc.p.end}}"
        beginCaptures: "#text_component.property"
        patterns:
          - include: "#text_component.string"
          - include: "#error.compound_value"

  text_component.property.color:
    patterns:
      - begin: "{{tc.p.begin_l}}(color){{tc.p.begin_r}}"
        end: "{{tc.p.end}}"
        beginCaptures: "#text_component.property"
        patterns:
          - include: "#text_component.string.color"
          - include: "#error.compound_value"

  text_component.property.extra_with:
    patterns:
      - begin: "{{tc.p.begin_l}}(extra|with){{tc.p.begin_r}}"
        end: "{{tc.p.end}}"
        beginCaptures: "#text_component.property"
        patterns:
          - include: "#text_component.list"
          - include: "#error.compound_value"

  text_component.property.selector:
    patterns:
      - begin: "{{tc.p.begin_l}}(selector){{tc.p.begin_r}}"
        end: "{{tc.p.end}}"
        beginCaptures: "#text_component.property"
        patterns:
          - include: "#text_component.string.selector"
          - include: "#error.compound_value"

  text_component.property.score:
    patterns:
      - begin: "{{tc.p.begin_l}}(score){{tc.p.begin_r}}"
        end: "{{tc.p.end}}"
        beginCaptures: "#text_component.property"
        patterns:
          - include: "#text_component.dict.score"
          - include: "#error.compound_value"

  text_component.property.keybind:
    patterns:
      - begin: "{{tc.p.begin_l}}(keybind){{tc.p.begin_r}}"
        end: "{{tc.p.end}}"
        beginCaptures: "#text_component.property"
        patterns:
          - include: "#text_component.string.keybind"
          - include: "#error.compound_value"

  text_component.property.insertion:
    patterns:
      - begin: "{{tc.p.begin_l}}(insertion){{tc.p.begin_r}}"
        end: "{{tc.p.end}}"
        beginCaptures: "#text_component.property"
        patterns:
          - include: "#text_component.string.insertion"
          - include: "#error.compound_value"

  text_component.property.clickEvent:
    patterns:
      - begin: "{{tc.p.begin_l}}(clickEvent){{tc.p.begin_r}}"
        end: "{{tc.p.end}}"
        beginCaptures: "#text_component.property"
        patterns:
          - include: "#text_component.dict.clickEvent"
          - include: "#error.compound_value"

  text_component.property.hoverEvent:
    patterns:
      - begin: "{{tc.p.begin_l}}(hoverEvent){{tc.p.begin_r}}"
        end: "{{tc.p.end}}"
        beginCaptures: "#text_component.property"
        patterns:
          - include: "#text_component.dict.hoverEvent"
          - include: "#error.compound_value"

  text_component.properties.score:
    patterns:
      # FIXME implement score sub-properties
      - include: "#error.compound_value"

  text_component.properties.clickEvent:
    patterns:
      # FIXME implement clickEvent sub-properties
      - include: "#error.compound_value"

  text_component.properties.hoverEvent:
    patterns:
      # FIXME implement hoverEvent sub-properties
      - include: "#error.compound_value"

  ##############################################################################
  # TARGET SELECTORS ###########################################################
  ##############################################################################

  # TODO consider version-controlling and generating target selector arguments

  target_selector.content:
    # NOTE Selectors are syntactically similar to dictionaries.
    # Unfortunately we cannot reuse common.dict here because selector arguments
    # require special handling with their character sets and terminals.
    patterns:
      # consume commas from argument value to argument key
      - name: meta._.argument_separator.content.target_selector.mcfunction
        match: '(?<=[^\[\,])(\,)(?={{pad}}\w)'
        captures:
          1:
            name: "#target_selector.comma"

      # consume whitespace from separator to argument key
      - match: '(?<=[\[\,]) +(?=\w)'

      # consume whitespace from argument to separator
      - match: '(?<=[^\[\,]) +(?=[\]\,])'

      # special case for empty parameterized selectors, e.g. `@e[ ]`
      - match: '(?<=\[) +(?=\])'

      - include: "#target_selector.arguments"

  target_selector.arguments:
    patterns:
      - include: "#target_selector.content.argument.xyz"
      - include: "#target_selector.content.argument.dxyz"
      - include: "#target_selector.content.argument.xy_rotation"
      - include: "#target_selector.content.argument.distance"
      - include: "#target_selector.content.argument.team"
      - include: "#target_selector.content.argument.tag"
      - include: "#target_selector.content.argument.name"
      - include: "#target_selector.content.argument.type"
      - include: "#target_selector.content.argument.level"
      - include: "#target_selector.content.argument.gamemode"
      - include: "#target_selector.content.argument.sort"
      - include: "#target_selector.content.argument.limit"
      - include: "#target_selector.content.argument.scores"
      - include: "#target_selector.content.argument.advancements"
      - include: "#target_selector.content.argument.nbt"

  target_selector.content.argument.xyz:
    patterns:
      - name: meta._.xyz.argument.content.target_selector.mcfunction
        match: '(x|y|z){{pad}}(\=){{pad}}{{double}}{{pad}}(?=[\]\,])'
        captures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
          3:
            name: "#number"

  target_selector.content.argument.dxyz:
    patterns:
      - name: meta._.dxyz.argument.content.target_selector.mcfunction
        match: '(dx|dy|dz){{pad}}(\=){{pad}}{{double}}{{pad}}(?=[\]\,])'
        captures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
          3:
            name: "#number"

  target_selector.content.argument.xy_rotation:
    patterns:
      - name: meta._.xy_rotation.argument.content.target_selector.mcfunction
        begin: '(x_rotation|y_rotation){{pad}}(\=){{pad}}(?=[^\n\]\,])'
        end: '{{ln}}|{{pad}}(?=[\]\,])'
        beginCaptures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
        patterns:
          - include: "#common.double_range"
          - include: "#error.command_line"

  target_selector.content.argument.distance:
    patterns:
      - name: meta._.distance.argument.content.target_selector.mcfunction
        begin: '(distance){{pad}}(\=){{pad}}(?=[^\n\]\,])'
        end: '{{ln}}|{{pad}}(?=[\]\,])'
        beginCaptures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
        patterns:
          - include: "#common.double_range"
          - include: "#error.command_line"

  target_selector.content.argument.team:
    patterns:
      - name: meta._.team.argument.content.target_selector.mcfunction
        match: '(team){{pad}}(\=){{pad}}(\!?){{pad}}{{scoreboard_team}}?{{pad}}(?=[\]\,])'
        captures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
          3:
            name: "#target_selector.not"
          4:
            name: "#scoreboard_team"

  target_selector.content.argument.tag:
    patterns:
      - name: meta._.tag.argument.content.target_selector.mcfunction
        match: '(tag){{pad}}(\=){{pad}}(\!?){{pad}}{{entity_tag}}?{{pad}}(?=[\]\,])'
        captures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
          3:
            name: "#target_selector.not"
          4:
            name: "#entity_tag"

  target_selector.content.argument.name:
    patterns:
      - name: meta._.name.argument.content.target_selector.mcfunction
        begin: '(name){{pad}}(\=){{pad}}(\!?){{pad}}'
        end: '{{ln}}|{{pad}}(?=[\]\,])'
        beginCaptures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
          3:
            name: "#target_selector.not"
        patterns:
          - include: "#common.quotable_string"
          - include: "#error.command_line"

  target_selector.content.argument.type:
    patterns:
      - name: meta._.type.argument.content.target_selector.mcfunction
        begin: '(type){{pad}}(\=){{pad}}(\!?){{pad}}(?=[^\n\]\,])'
        end: '{{ln}}|{{pad}}(?=[\]\,])'
        beginCaptures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
          3:
            name: "#target_selector.not"
        patterns:
          - include: "#common.taggable_resource_location"
          - include: "#error.command_line"

  target_selector.content.argument.level:
    patterns:
      - name: meta._.level.argument.content.target_selector.mcfunction
        begin: '(level){{pad}}(\=){{pad}}(?=[^\n\]\,])'
        end: '{{ln}}|{{pad}}(?=[\]\,])'
        beginCaptures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
        patterns:
          - include: "#common.integer_range"
          - include: "#error.command_line"

  target_selector.content.argument.gamemode:
    patterns:
      - name: meta._.gamemode.argument.content.target_selector.mcfunction
        match: '(gamemode){{pad}}(\=){{pad}}(\!?){{pad}}{{selector_gamemode_choices}}{{pad}}(?=[\]\,])'
        captures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
          3:
            name: "#target_selector.not"
          4:
            name: "#keyword"

  target_selector.content.argument.sort:
    patterns:
      - name: meta._.sort.argument.content.target_selector.mcfunction
        match: '(sort){{pad}}(\=){{pad}}{{selector_sort_choices}}{{pad}}(?=[\]\,])'
        captures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
          3:
            name: "#keyword"

  target_selector.content.argument.limit:
    patterns:
      - name: meta._.limit.argument.content.target_selector.mcfunction
        match: '(limit){{pad}}(\=){{pad}}{{positive_integer}}{{pad}}(?=[\]\,])'
        captures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
          3:
            name: "#number"

  target_selector.content.argument.scores:
    patterns:
      - name: meta._.scores.argument.content.target_selector.mcfunction
        begin: '(scores){{pad}}(\=){{pad}}(\{)'
        end: '{{ln}}|(\}){{pad}}(?=[\]\,])'
        beginCaptures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
          3:
            name: "#score_map.bracket"
        endCaptures:
          1:
            name: "#score_map.bracket"
        patterns:
          - include: "#score_map.content"

  target_selector.content.argument.advancements:
    patterns:
      - name: meta._.advancements.argument.content.target_selector.mcfunction
        begin: '(advancements){{pad}}(\=){{pad}}(\{)'
        end: '{{ln}}|(\}){{pad}}(?=[\]\,])'
        beginCaptures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
          3:
            name: "#advancement_map.bracket"
        endCaptures:
          1:
            name: "#advancement_map.bracket"
        patterns:
          - include: "#advancement_map.content"

  target_selector.content.argument.nbt:
    patterns:
      - name: meta._.nbt.argument.content.target_selector.mcfunction
        begin: '(nbt){{pad}}(\=){{pad}}(\!?){{pad}}(\{)'
        end: '{{ln}}|(\}){{pad}}(?=[\]\,])'
        beginCaptures:
          1:
            name: "#target_selector.param"
          2:
            name: "#target_selector.equals"
          3:
            name: "#target_selector.not"
          4:
            name: "#nbt.compound_bracket"
        endCaptures:
          1:
            name: "#nbt.compound_bracket"
        patterns:
          - include: "#nbt.compound.content"

  ##############################################################################
  # GENERATED COMMANDS #########################################################
  ##############################################################################

  generated.commands:
    # this is where the generator will inject command patterns
    patterns:
      - include: "#generated.command.say"
      - include: "#generated.command.tellraw"
      - include: "#generated.command.execute"
      - include: "#error.command_line"

  generated.command.say:
    begin: "(say){{cbx_false}}"
    end: "{{ln}}"
    beginCaptures:
      1:
        name: "#command"
    patterns:
      - include: "#generated.commands.say"

  generated.commands.say:
    patterns:
      - include: "#generated.command.say.message"
      - include: "#error.command_line"

  generated.command.say.message:
    # minecraft:message is an exception
    # it just consume the rest of the line, attempting to
    # parse various patterns (such as selectors) as it goes
    patterns:
      - include: "#common.message"

  generated.command.tellraw:
    begin: "(tellraw){{cbx_false}}"
    end: "{{ln}}"
    beginCaptures:
      1:
        name: "#command"
    patterns:
      - include: "#generated.commands.tellraw"

  generated.commands.tellraw:
    patterns:
      - include: "#generated.command.tellraw.targets"
      - include: "#error.command_line"

  generated.command.tellraw.targets:
    # this should only allow players, but using regex is not viable
    patterns:
      # (1) selector without arguments
      - begin: "{{basic_target_selector}}{{cbx_false}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#target_selector.base"
        patterns:
          - include: "#generated.commands.tellraw.targets"

      # (2) uuid
      - begin: "{{uuid}}{{cbx_false}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#target.uuid"
        patterns:
          - include: "#generated.commands.tellraw.targets"

      # (3) player name
      - begin: "{{player_name}}{{cbx_false}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#target.player_name"
        patterns:
          - include: "#generated.commands.tellraw.targets"

      # (4) selector with arguments
      - begin: "{{parameterized_target_selector.begin}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#target_selector.base"
          2:
            name: "#target_selector.bracket"
        patterns:
          - begin: "{{parameterized_target_selector.next}}{{cbx_false}}"
            end: "{{ln}}"
            beginCaptures:
              1:
                name: "#target_selector.bracket"
            patterns:
              - include: "#generated.commands.tellraw.targets"
          - include: "#target_selector.content"
          - include: "#error.command_line"

      - include: "#error.command_line"

  generated.commands.tellraw.targets:
    patterns:
      - include: "#text_component"
      - include: "#error.command_line"

  generated.command.execute:
    # `execute` is non-executable
    begin: "(execute){{cbx_false}}"
    end: "{{ln}}"
    beginCaptures:
      1:
        name: "#command"
    patterns:
      - include: "#generated.commands.execute"

  generated.commands.execute:
    # define child commands separately so they can be re-used in redirects
    patterns:
      - include: "#generated.command.execute.run"
      - include: "#generated.command.execute.as"
      - include: "#error.command_line"

  generated.command.execute.run:
    # `execute run` is executable
    begin: "(run){{cbx_true}}"
    end: "{{ln}}"
    beginCaptures:
      1:
        name: "#subcommand"
    patterns:
      - include: "#generated.commands.execute.run"

  generated.commands.execute.run:
    # redirect to root
    patterns:
      - include: "#generated.commands"

  generated.command.execute.as:
    # `execute as` is non-executable
    begin: "(as){{cbx_false}}"
    end: "{{ln}}"
    beginCaptures:
      1:
        name: "#subcommand"
    patterns:
      - include: "#generated.commands.execute.as"

  generated.commands.execute.as:
    patterns:
      - include: "#generated.command.execute.as.targets"
      - include: "#error.command_line"

  generated.command.execute.as.targets:
    # `execute as <targets>` is executable
    patterns:
      # unfortunately we cannot generalize these, because
      # we need to keep the context of the parent command

      # we can use basic `match` patterns for the simpler parsers (1-3)

      # (1) selector without arguments
      - begin: "{{basic_target_selector}}{{cbx_true}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#target_selector.base"
        patterns:
          - include: "#generated.commands.execute.as.targets"

      # (2) uuid
      - begin: "{{uuid}}{{cbx_true}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#target.uuid"
        patterns:
          - include: "#generated.commands.execute.as.targets"

      # (3) player name
      - begin: "{{player_name}}{{cbx_true}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#target.player_name"
        patterns:
          - include: "#generated.commands.execute.as.targets"

      # but more complex parsers will require further diving (4)

      # (4) selector with arguments
      - begin: "{{parameterized_target_selector.begin}}"
        end: "{{ln}}"
        beginCaptures:
          1:
            name: "#target_selector.base"
          2:
            name: "#target_selector.bracket"
        patterns:
          # the ending brace pattern cannot be generalized,
          # because it needs to return to a specific parent command
          - begin: "{{parameterized_target_selector.next}}{{cbx_true}}"
            end: "{{ln}}"
            beginCaptures:
              1:
                name: "#target_selector.bracket"
            patterns:
              # now we can finally resume back to the command arguments
              - include: "#generated.commands.execute.as.targets"

          # this is where common selector patterns can be included
          - include: "#target_selector.content"

          # this doesn't go in common selector patterns, because it invalidates
          # rest of the line... which wouldn't make sense in other future
          # potential scopes, like text components
          - include: "#error.command_line"

      - include: "#error.command_line"

  generated.commands.execute.as.targets:
    # redirect to `execute`
    patterns:
      - include: "#generated.commands.execute"
