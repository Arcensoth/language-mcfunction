---
name: mcfunction
scopeName: source.mcfunction
fileTypes:
  - mcfunction

variables:
  lookahead_newline: '(?=\n)'

  command_token_delim: '[ \n]'
  not_command_token_delim: '[^ \n]'

  command_token_l: "(?<= )"
  command_token_r: '(?=[ \n])'

  selector_argument_terminal: '(?= *[\,\]\n])'
  sat: "{{selector_argument_terminal}}"

  # characters for literal subcommands and other strict word-like identifiers
  literal: "([a-z_][a-z0-9_]*)"

  # characters permitted in namespaces, resource paths, etc
  component_nc: '[a-z0-9_\.\-]+'
  component: "({{component_nc}})"

  # an integer or decimal with optional leading digit
  number: '(\-?\d*\.?\d+)'

  # a resource path is the portion of the resource location following the namesapce
  resource_path: '([a-z0-9_\.\-\/]+)'

  # resource locations: namespace + path
  # TODO improve resource location validity
  # resource_location: '{{component}}(\:)({{component_nc}}(?:\/{{component_nc}})*)'
  resource_location: '{{component}}(\:){{resource_path}}'

  # uuid format
  hex_digit: "[0-9a-fA-F]"
  uuid: "({{hex_digit}}+(?:(-){{hex_digit}}+){4})"

  # various popular fakeplayer formats
  # they'd get classified as unquoted strings anyway
  fakeplayer: '([\#\$\%][\w\.\-]+)'

  # unquoted strings are like literals with additional available characters
  # TODO check what the game allows for word-type string arguments
  unquoted_string: '([\w\.\-\#\$\%]+)'

  # a tagged resource location is a resource location prefaced with `#`
  tagged_resource_location: '(\#){{resource_location}}'

  # relative or local coordinate
  coordinate: '([\~\^]){{number}}?'

  # numeric range
  range: '{{number}}?(\.\.){{number}}?'

  # base selectors are defined with a single, lower-case character
  base_selector: '(\@[a-z])'

  # group names, in one place
  name.brace_delims: markup.bold.mcfunction
  name.numeric_constant: constant.numeric.mcfunction
  name.numeric_altered: constant.character.escape.mcfunction
  name.range_ellipsis: keyword.control.mcfunction
  name.coordinate_operator: keyword.control.mcfunction
  name.base_selector: variable.language.mcfunction
  name.selector_delims: "{{name.brace_delims}}"
  name.resource_location: entity.name.function.mcfunction
  name.tagged_resource_location: constant.character.escape.mcfunction
  name.uuid: "{{name.base_selector}}"
  name.fakeplayer: "{{name.base_selector}}"
  name.literal: keyword.operator.mcfunction
  name.unquoted_string: string.unquoted.mcfunction
  name.quoted_string: string.quoted.mcfunction
  name.quoted_string_escape: constant.character.mcfunction
  name.unknown: invalid.illegal.mcfunction
  name.error: invalid.illegal.mcfunction

patterns:
  - include: "#comment"
  - include: "#command"
  - include: "#unknown"

capturesRepository:
  selector_without_arguments:
    1:
      name: "{{name.base_selector}}"

  resource_location:
    1:
      # the namespace
      name: "{{name.resource_location}}"
    2:
      # the `:`
      name: "{{name.resource_location}}"
    3:
      # the path
      name: "{{name.resource_location}}"

  tagged_resource_location:
    1:
      # the `#`
      name: "{{name.tagged_resource_location}}"
    2:
      # the namespace
      name: "{{name.tagged_resource_location}}"
    3:
      # the `:`
      name: "{{name.tagged_resource_location}}"
    4:
      # the path
      name: "{{name.tagged_resource_location}}"

  range:
    # TODO catch `..` error case
    1:
      # the number on the left side
      name: "{{name.numeric_altered}}"
    2:
      # color the `..` differently to distinguish it from decimals
      name: "{{name.range_ellipsis}}"
    3:
      # the number on the right side
      name: "{{name.numeric_altered}}"

  number:
    1:
      name: "{{name.numeric_constant}}"

  coordinate:
    1:
      # the `~` or `^`
      name: "{{name.coordinate_operator}}"
    2:
      # the actual number
      name: "{{name.numeric_altered}}"

  literal:
    1:
      name: "{{name.literal}}"

  uuid:
    1:
      name: "{{name.uuid}}"

  fakeplayer:
    1:
      name: "{{name.fakeplayer}}"

  unquoted_string:
    1:
      name: "{{name.unquoted_string}}"

repository:
  comment:
    patterns:
      - name: meta.comment.mcfunction
        match: '^\s*(#.*)$'
        captures:
          1:
            name: comment.number-sign.mcfunction
            patterns:
              # things that need attention, like todos and fixmes
              - name: meta.comment.todo.mcfunction
                match: '#\s*((?:TODO|FIXME|DELETEME)\s.*)$'
                captures:
                  1:
                    name: markup.bold.mcfunction
              # doc tags like `@params` and `@returns`
              - name: meta.comment.annotation.mcfunction
                match: '#\s*(\@\w*)\s.*$'
                captures:
                  1:
                    name: markup.bold.mcfunction
              # headers for separating blocks
              - name: meta.comment.annotation.mcfunction
                match: '##\s*(.*)$'
                captures:
                  1:
                    name: markup.heading.mcfunction

  command:
    patterns:
      - name: meta.command.mcfunction
        begin: '^\s*{{literal}}[ \n]'
        end: "$"
        beginCaptures:
          # highlight the first command on each line
          1:
            name: keyword.control.mcfunction
        patterns:
          # don't name this one yet, we want to get rid of the space
          - begin: "(?<= )"
            # consume the space
            end: '[ \n]'

            # for debugging purposes...
            # end: '([ \n])'
            # endCaptures:
            #   1:
            #     name: markup.underline.debug.mcfunction

            # name everything inside as part of the token
            contentName: meta.command.token.mcfunction
            patterns:
              - include: "#command.tokens"

  unknown:
    patterns:
      - name: meta.unknown.mcfunction
        match: "^(.*)$"
        captures:
          1:
            name: "{{name.unknown}}"

  command.tokens:
    patterns:
      - include: "#command.token.selector_with_arguments"
      - include: "#command.token.selector_without_arguments"
      - include: "#command.token.resource_location"
      - include: "#command.token.tagged_resource_location"
      - include: "#command.token.range"
      - include: "#command.token.number"
      - include: "#command.token.coordinate"
      # we literals before strings, because literals are a subset of strings
      - include: "#command.token.literal"
      - include: "#command.token.uuid"
      - include: "#command.token.fakeplayer"
      - include: "#command.token.unquoted_string"
      - include: "#command.token.quoted_string"
      - include: "#command.token.unknown"

  command.token.selector_without_arguments:
    name: meta.command.token.selector_without_arguments.mcfunction
    match: "{{command_token_l}}{{base_selector}}{{command_token_r}}"
    captures: "#selector_without_arguments"

  command.token.resource_location:
    name: meta.command.token.resource_location.mcfunction
    match: "{{command_token_l}}{{resource_location}}{{command_token_r}}"
    captures: "#resource_location"

  command.token.tagged_resource_location:
    name: meta.command.token.tagged_resource_location.mcfunction
    match: "{{command_token_l}}{{tagged_resource_location}}{{command_token_r}}"
    captures: "#tagged_resource_location"

  command.token.range:
    name: meta.command.token.range.mcfunction
    match: "{{command_token_l}}{{range}}{{command_token_r}}"
    captures: "#range"

  command.token.number:
    name: meta.command.token.number.mcfunction
    match: "{{command_token_l}}{{number}}{{command_token_r}}"
    captures: "#number"

  command.token.coordinate:
    name: meta.command.token.coordinate.mcfunction
    match: "{{command_token_l}}{{coordinate}}{{command_token_r}}"
    captures: "#coordinate"

  command.token.literal:
    name: meta.command.token.literal.mcfunction
    match: "{{command_token_l}}{{literal}}{{command_token_r}}"
    captures: "#literal"

  command.token.uuid:
    name: meta.command.token.uuid.mcfunction
    match: "{{command_token_l}}{{uuid}}{{command_token_r}}"
    captures: "#uuid"

  command.token.fakeplayer:
    name: meta.command.token.fakeplayer.mcfunction
    match: "{{command_token_l}}{{fakeplayer}}{{command_token_r}}"
    captures: "#fakeplayer"

  command.token.unquoted_string:
    name: meta.command.token.unquoted_string.mcfunction
    match: "{{command_token_l}}{{unquoted_string}}{{command_token_r}}"
    captures: "#unquoted_string"

  command.token.unknown:
    name: meta.command.token.unknown.mcfunction
    match: '{{command_token_l}}([^ \n]*){{command_token_r}}'
    captures:
      1:
        name: "{{name.unknown}}"

  command.token.quoted_string:
    # quoted strings are a recursive format captured between the quotes
    name: meta.command.token.quoted_string.mcfunction

    # TODO how do we highlight the whole thing as an error, if any part of it fails?

    # begin whenever we see a quote
    begin: '{{command_token_l}}(\")'

    # End on anything. This is tricky. If we got to this point, it means the
    # child scope has been terminated. According to the child scope, the only
    # things that can get us here are an unescaped quote or a newline (which
    # cannot be escaped). Also make sure to mark anything following an ending
    # quote to the next token delimiter as an error.
    end: '{{lookahead_newline}}|(\")({{not_command_token_delim}}*)'

    beginCaptures:
      1:
        name: "{{name.quoted_string}}"

    endCaptures:
      1:
        name: "{{name.quoted_string}}"
      2:
        name: "{{name.error}}"

    patterns:
      - include: "#common.quoted_string"

  command.token.selector_with_arguments:
    name: meta.command.token.selector_with_arguments.mcfunction

    # Begin whenever we see a base selector followed by an opening square brace.
    begin: '{{command_token_l}}{{base_selector}}(\[)'

    # Similar to quotes, we have two distinct ending cases.
    #   1. End on a newline, without consuming it. This is technically an error
    #      case, but will occur frequently with unfinished selectors; e.g. while
    #      the user is typing a selector at the end of a line.
    #   2. End on any other character, although according to the child scope it
    #      should only ever be a closing square brace. The child scope does not
    #      consume the closing brace, and so it becomes our job to check for
    #      erroneous trailing data and to advance the next token.
    end: '{{lookahead_newline}}|(\])({{not_command_token_delim}}*)'

    beginCaptures:
      1:
        name: "{{name.selector_delims}}"
      2:
        name: "{{name.selector_delims}}"

    endCaptures:
      1:
        name: "{{name.selector_delims}}"
      2:
        name: "{{name.error}}"

    patterns:
      # consume whitespace in between arguments
      - name: meta.selector.argument_spacing.mcfunction
        match: " +"
      # now the fun part: recurse yet again whenever we encounter an argument
      - name: meta.selector.argument.mcfunction

        # Begin as soon as we see a key, equals, and optional negation operator.
        begin: '{{literal}} *(\=) *(\!)? *'

        # End in three distinct cases:
        #   1. Comma followed immediately by a terminal. Consume the comma, but
        #      not the terminal. This is an error case.
        #   2. Just a comma. This is the expected case and we can proceed fine.
        #   3. just a terminal. Also an error case.
        end: '(\,)(?=[\]\n])|(\,)|(?=[\]\n])'

        beginCaptures:
          1:
            # the key
            name: "variable.parameter.mcfunction"
          2:
            # the `=`
            name: "{{name.selector_delims}}"
          3:
            # the optional `!`
            name: "keyword.control.mcfunction"

        endCaptures:
          1:
            # the `,` in invalid case (1)
            name: "{{name.error}}"
          2:
            # the `,` in valid case (2)
            name: "{{name.selector_delims}}"

        patterns:
          - include: "#selector.argument.resource_location"
          - include: "#selector.argument.tagged_resource_location"
          - include: "#selector.argument.range"
          - include: "#selector.argument.number"
          - include: "#selector.argument.literal"
          - include: "#selector.argument.unquoted_string"
          - include: "#selector.argument.quoted_string"
          - include: "#selector.argument.unknown"

      # anything else apart from terminals is classified as an error
      - name: "{{name.error}}"
        match: '[^\]\n]+'

  selector.argument.resource_location:
    name: meta.selector.argument.resource_location.mcfunction
    match: "{{resource_location}}{{sat}}"
    captures: "#resource_location"

  selector.argument.tagged_resource_location:
    name: meta.selector.argument.tagged_resource_location.mcfunction
    match: "{{tagged_resource_location}}{{sat}}"
    captures: "#tagged_resource_location"

  selector.argument.range:
    name: meta.selector.argument.range.mcfunction
    match: "{{range}}{{sat}}"
    captures: "#range"

  selector.argument.number:
    name: meta.selector.argument.number.mcfunction
    match: "{{number}}{{sat}}"
    captures: "#number"

  selector.argument.literal:
    name: meta.selector.argument.literal.mcfunction
    match: "{{literal}}{{sat}}"
    captures: "#literal"

  selector.argument.unquoted_string:
    name: meta.selector.argument.unquoted_string.mcfunction
    match: "{{unquoted_string}}{{sat}}"
    captures: "#unquoted_string"

  selector.argument.quoted_string:
    name: meta.selector.argument.quoted_string.mcfunction
    begin: '(\")'
    end: '{{lookahead_newline}}|(\")([^\]\,\n]*)'
    beginCaptures:
      1:
        name: "{{name.quoted_string}}"
    endCaptures:
      1:
        name: "{{name.quoted_string}}"
      2:
        # anything trailing after the quote, apart from terminals, is an error
        name: "{{name.error}}"
    patterns:
      - include: "#common.quoted_string"

  selector.argument.unknown:
    name: meta.selector.argument.unknown.mcfunction
    match: '([^\]\n\,]+)'
    captures:
      1:
        name: "{{name.unknown}}"

  common.quoted_string:
    patterns:
      # consume everything except for backslashes, quotes, and newlines
      - name: "{{name.quoted_string}}"
        match: '[^\\\"\n]'
      # consume any escaped characters... except for newlines
      - name: "{{name.quoted_string_escape}}"
        match: '\\[^\n]'
      # consume a single backslash (implicitly followed by a newline) as an error
      - name: "{{name.error}}"
        match: '\\'
      # anything else will be handed back to the parent scope
