---
name: mcfunction
scopeName: source.mcfunction
fileTypes:
  - mcfunction

variables:
  lookahead_newline: '(?=\n)'

  command_token_delim: '[ \n]'
  not_command_token_delim: '[^ \n]'

  command_token_l: "(?<= )"
  command_token_r: '(?=[ \n])'

  selector_argument_terminal: '(?= *[\,\]\n])'
  sat: "{{selector_argument_terminal}}"

  block_predicate_argument_terminal: "{{sat}}"
  bpat: "{{block_predicate_argument_terminal}}"

  # boolean true/false
  boolean: "(true|false)"

  # math/numeric operations
  operation: '(\%\=|\*\=|\+\=|\-\=|\/\=|\<|\=|\>|\>\<|\<\=|\>\=)'

  # characters for literal subcommands and other strict word-like identifiers
  literal: "([a-z_][a-z0-9_]*)"

  # characters permitted in namespaces, resource paths, etc
  component_nc: '[a-z0-9_\.\-]+'
  component: "({{component_nc}})"

  # an integer or decimal with optional leading digit
  number: '(\-?\d*\.?\d+)'

  # a resource path is the portion of the resource location following the namesapce
  resource_path: '([a-z0-9_\.\-\/]+)'

  # resource locations: namespace + path
  # TODO improve resource location validity
  # resource_location: '{{component}}(\:)({{component_nc}}(?:\/{{component_nc}})*)'
  resource_location: '{{component}}(\:){{resource_path}}'

  # uuid format
  hex_digit: "[0-9a-fA-F]"
  uuid: "({{hex_digit}}+(?:(-){{hex_digit}}+){4})"

  # various popular fakeplayer formats
  # they'd get classified as unquoted strings anyway
  fakeplayer: '([\#\$\%][\w\.\-]+)'

  # unquoted strings are like literals with additional available characters
  # TODO check what the game allows for word-type string arguments
  unquoted_string: '([\w\.\-\#\$\%]+)'

  # a tagged resource location is a resource location prefaced with `#`
  tagged_resource_location: '(\#){{resource_location}}'

  # relative or local coordinate
  coordinate: '([\~\^]){{number}}?'

  # numeric range
  range: '{{number}}?(\.\.){{number}}?'

  # base selectors are defined with a single, lower-case character
  base_selector: '(\@[a-z])'

  # group names, in one place
  name.brace_delims: markup.bold.mcfunction
  name.dict_key: variable.parameter.mcfunction
  name.numeric_constant: constant.numeric.mcfunction
  name.numeric_altered: constant.character.escape.mcfunction
  name.range_ellipsis: keyword.control.mcfunction
  name.coordinate_operator: keyword.control.mcfunction
  name.base_selector: variable.language.mcfunction
  name.selector_delims: "{{name.brace_delims}}"
  name.block_predicate_delims: "{{name.brace_delims}}"
  name.nbt_delims: "{{name.brace_delims}}"
  name.nbt_key: "{{name.dict_key}}"
  name.nbt_index: constant.numeric.mcfunction
  name.resource_location: entity.name.function.mcfunction
  name.tagged_resource_location: constant.character.escape.mcfunction
  name.uuid: "{{name.base_selector}}"
  name.fakeplayer: "{{name.base_selector}}"
  name.boolean: support.type.mcfunction
  name.operation: keyword.control.mcfunction
  name.literal: keyword.operator.mcfunction
  name.unquoted_string: string.unquoted.mcfunction
  name.quoted_string: string.quoted.mcfunction
  name.quoted_string_escape: constant.character.mcfunction
  name.unknown: invalid.illegal.mcfunction
  name.error: invalid.illegal.mcfunction

patterns:
  - include: "#comment"
  - include: "#command"
  - include: "#unknown"

capturesRepository:
  selector_without_arguments:
    1:
      name: "{{name.base_selector}}"

  resource_location:
    1:
      # the namespace
      name: "{{name.resource_location}}"
    2:
      # the `:`
      name: "{{name.resource_location}}"
    3:
      # the path
      name: "{{name.resource_location}}"

  tagged_resource_location:
    1:
      # the `#`
      name: "{{name.tagged_resource_location}}"
    2:
      # the namespace
      name: "{{name.tagged_resource_location}}"
    3:
      # the `:`
      name: "{{name.tagged_resource_location}}"
    4:
      # the path
      name: "{{name.tagged_resource_location}}"

  range:
    # TODO catch `..` error case
    1:
      # the number on the left side
      name: "{{name.numeric_altered}}"
    2:
      # color the `..` differently to distinguish it from decimals
      name: "{{name.range_ellipsis}}"
    3:
      # the number on the right side
      name: "{{name.numeric_altered}}"

  number:
    1:
      name: "{{name.numeric_constant}}"

  coordinate:
    1:
      # the `~` or `^`
      name: "{{name.coordinate_operator}}"
    2:
      # the actual number
      name: "{{name.numeric_altered}}"

  boolean:
    1:
      name: "{{name.boolean}}"

  operation:
    1:
      name: "{{name.operation}}"

  literal:
    1:
      name: "{{name.literal}}"

  uuid:
    1:
      name: "{{name.uuid}}"

  fakeplayer:
    1:
      name: "{{name.fakeplayer}}"

  unquoted_string:
    1:
      name: "{{name.unquoted_string}}"

repository:
  comment:
    patterns:
      - name: meta.comment.mcfunction
        match: '^\s*(#.*)$'
        captures:
          1:
            name: comment.number-sign.mcfunction
            patterns:
              # things that need attention, like todos and fixmes
              - name: meta.comment.todo.mcfunction
                match: '#\s*((?:TODO|FIXME|DELETEME)\b.*)$'
                captures:
                  1:
                    name: markup.bold.mcfunction
              # doc tags like `@params` and `@returns`
              - name: meta.comment.annotation.mcfunction
                match: '#\s*(\@\w*)\b.*$'
                captures:
                  1:
                    name: markup.bold.mcfunction
              # headers for separating blocks
              - name: meta.comment.annotation.mcfunction
                match: '##\s*(.*)$'
                captures:
                  1:
                    name: markup.heading.mcfunction

  command:
    patterns:
      - name: meta.command.mcfunction
        begin: '^\s*{{literal}}[ \n]'
        end: "$"
        beginCaptures:
          # highlight the first command on each line
          1:
            name: keyword.control.mcfunction
        patterns:
          # don't name this one yet, we want to get rid of the space
          - begin: "(?<= )"
            # consume the space
            end: '[ \n]'

            # for debugging purposes...
            # end: '([ \n])'
            # endCaptures:
            #   1:
            #     name: markup.underline.debug.mcfunction

            # name everything inside as part of the token
            contentName: meta.command.token.mcfunction
            patterns:
              - include: "#command.tokens"

  unknown:
    patterns:
      - name: meta.unknown.mcfunction
        match: "^(.*)$"
        captures:
          1:
            name: "{{name.unknown}}"

  command.tokens:
    patterns:
      - include: "#command.token.nbt_compound"
      - include: "#command.token.nbt_list"
      - include: "#command.token.selector_with_arguments"
      - include: "#command.token.selector_without_arguments"
      - include: "#command.token.block_predicate"
      - include: "#command.token.tagged_block_predicate"
      - include: "#command.token.resource_location"
      - include: "#command.token.tagged_resource_location"
      - include: "#command.token.range"
      - include: "#command.token.number"
      - include: "#command.token.coordinate"
      - include: "#command.token.boolean"
      - include: "#command.token.operation"
      - include: "#command.token.literal"
      - include: "#command.token.uuid"
      - include: "#command.token.fakeplayer"
      - include: "#command.token.nbt_path"
      - include: "#command.token.unquoted_string"
      - include: "#command.token.quoted_string"
      - include: "#command.token.unknown"

  command.token.selector_without_arguments:
    name: meta.command.token.selector_without_arguments.mcfunction
    match: "{{command_token_l}}{{base_selector}}{{command_token_r}}"
    captures: "#selector_without_arguments"

  command.token.resource_location:
    name: meta.command.token.resource_location.mcfunction
    match: "{{command_token_l}}{{resource_location}}{{command_token_r}}"
    captures: "#resource_location"

  command.token.tagged_resource_location:
    name: meta.command.token.tagged_resource_location.mcfunction
    match: "{{command_token_l}}{{tagged_resource_location}}{{command_token_r}}"
    captures: "#tagged_resource_location"

  command.token.range:
    name: meta.command.token.range.mcfunction
    match: "{{command_token_l}}{{range}}{{command_token_r}}"
    captures: "#range"

  command.token.number:
    name: meta.command.token.number.mcfunction
    match: "{{command_token_l}}{{number}}{{command_token_r}}"
    captures: "#number"

  command.token.coordinate:
    name: meta.command.token.coordinate.mcfunction
    match: "{{command_token_l}}{{coordinate}}{{command_token_r}}"
    captures: "#coordinate"

  command.token.boolean:
    name: meta.command.token.boolean.mcfunction
    match: "{{command_token_l}}{{boolean}}{{command_token_r}}"
    captures: "#boolean"

  command.token.operation:
    name: meta.command.token.operation.mcfunction
    match: "{{command_token_l}}{{operation}}{{command_token_r}}"
    captures: "#operation"

  command.token.literal:
    name: meta.command.token.literal.mcfunction
    match: "{{command_token_l}}{{literal}}{{command_token_r}}"
    captures: "#literal"

  command.token.uuid:
    name: meta.command.token.uuid.mcfunction
    match: "{{command_token_l}}{{uuid}}{{command_token_r}}"
    captures: "#uuid"

  command.token.fakeplayer:
    name: meta.command.token.fakeplayer.mcfunction
    match: "{{command_token_l}}{{fakeplayer}}{{command_token_r}}"
    captures: "#fakeplayer"

  command.token.unquoted_string:
    name: meta.command.token.unquoted_string.mcfunction
    match: "{{command_token_l}}{{unquoted_string}}{{command_token_r}}"
    captures: "#unquoted_string"

  command.token.unknown:
    name: meta.command.token.unknown.mcfunction
    match: '{{command_token_l}}([^ \n]*){{command_token_r}}'
    captures:
      1:
        name: "{{name.unknown}}"

  command.token.nbt_compound:
    name: meta.command.token.nbt_compound.mcfunction
    begin: '{{command_token_l}}(\{)'
    end: '{{lookahead_newline}}|(\})({{not_command_token_delim}}*)'
    beginCaptures:
      1:
        name: "{{name.nbt_delims}}"
    endCaptures:
      1:
        name: "{{name.nbt_delims}}"
      2:
        name: "{{name.error}}"
    patterns:
      - include: "#nbt.compound"

  command.token.nbt_list:
    name: meta.command.token.nbt_list.mcfunction
    begin: '{{command_token_l}}(\[)'
    end: '{{lookahead_newline}}|(\])({{not_command_token_delim}}*)'
    beginCaptures:
      1:
        name: "{{name.nbt_delims}}"
    endCaptures:
      1:
        name: "{{name.nbt_delims}}"
      2:
        name: "{{name.error}}"
    patterns:
      - include: "#nbt.list"

  nbt.compound:
    patterns:
      # skip whitespace: {( )SelectedItem : { Count : 64 } }
      - match: " +"

      # TODO quoted keys?

      # unquoted keys: { (SelectedItem) (:) { Count: 64 } }
      - begin: '(,)? *(\w+) *(\:) *'

        # Possible ending cases:
        #   1. the closing brace of the parent compound
        #   2. the comma separating the next element
        #   3. newline (error case)
        end: ' *(?=[\n\}\,])'

        beginCaptures:
          1:
            name: "{{name.nbt_delims}}"
          2:
            name: "{{name.nbt_key}}"
          3:
            name: "{{name.nbt_delims}}"

        patterns:
          - include: "#nbt.value"

      # anything else apart from separators and terminals is an error
      - match: '[^\n\}\,]+'
        name: "{{name.error}}"

  nbt.list:
    patterns:
      # skip whitespace: [( )1 , 2 , 3]
      - match: " +"

      # values: [ 1 (,) (2) , 3]
      # begin on anything that is not a terminal or separator
      - begin: '(,)? *(?=[^\n\]\,])'

        # Possible ending cases:
        #   1. the closing brace of the parent compound
        #   2. the comma separating the next element
        #   3. newline (error case)
        end: ' *(?=[\n\]\,])'

        beginCaptures:
          1:
            name: "{{name.nbt_delims}}"

        patterns:
          - include: "#nbt.value"

      - match: '[^\n\]\,]+'
        name: "{{name.error}}"

  nbt.value:
    patterns:
      - begin: '(\{)'
        end: '{{lookahead_newline}}|(\})'
        beginCaptures:
          1:
            name: "{{name.nbt_delims}}"
        endCaptures:
          1:
            name: "{{name.nbt_delims}}"
        patterns:
          - include: "#nbt.compound"
      - begin: '(\[)'
        end: '{{lookahead_newline}}|(\])'
        beginCaptures:
          1:
            name: "{{name.nbt_delims}}"
        endCaptures:
          1:
            name: "{{name.nbt_delims}}"
        patterns:
          - include: "#nbt.list"
      - begin: '(\")'
        end: '{{lookahead_newline}}|(\")'
        beginCaptures:
          1:
            name: "{{name.quoted_string}}"
        endCaptures:
          1:
            name: "{{name.quoted_string}}"
        patterns:
          - include: "#common.quoted_string"
      - match: "{{boolean}}"
        name: "{{name.boolean}}"
      - match: "{{number}}"
        name: "{{name.numeric_constant}}"
      - match: "{{unquoted_string}}"
        name: "{{name.unquoted_string}}"
      - match: '[^\n\,\]\}]+'
        name: "{{name.error}}"

  command.token.quoted_string:
    # quoted strings are a recursive format captured between the quotes
    name: meta.command.token.quoted_string.mcfunction

    # TODO how do we highlight the whole thing as an error, if any part of it fails?

    # begin whenever we see a quote
    begin: '{{command_token_l}}(\")'

    # End on anything. This is tricky. If we got to this point, it means the
    # child scope has been terminated. According to the child scope, the only
    # things that can get us here are an unescaped quote or a newline (which
    # cannot be escaped). Also make sure to mark anything following an ending
    # quote to the next token delimiter as an error.
    end: '{{lookahead_newline}}|(\")({{not_command_token_delim}}*)'

    beginCaptures:
      1:
        name: "{{name.quoted_string}}"

    endCaptures:
      1:
        name: "{{name.quoted_string}}"
      2:
        name: "{{name.error}}"

    patterns:
      - include: "#common.quoted_string"

  command.token.block_predicate:
    # This whole thing is going to look a lot like selector arguments.

    name: meta.command.token.block_predicate.mcfunction

    # Begin whenever we see a resource location followed by an opening square brace.
    begin: '{{command_token_l}}{{resource_location}}(\[)'

    # Similar to selector arguments; end in several cases.
    end: '{{lookahead_newline}}|(\])({{not_command_token_delim}}*)'

    beginCaptures:
      # TODO refactor repeated code (groups 1-3)
      1:
        # the namespace
        name: "{{name.resource_location}}"
      2:
        # the `:`
        name: "{{name.resource_location}}"
      3:
        # the path
        name: "{{name.resource_location}}"
      4:
        # the opening brace
        name: "{{name.block_predicate_delims}}"

    endCaptures:
      1:
        name: "{{name.block_predicate_delims}}"
      2:
        name: "{{name.error}}"

    patterns:
      - include: "#block_predicate.arguments"

  command.token.tagged_block_predicate:
    # Same as without a tag... all for a different colour.
    # TODO can we reduce thr amount of repeated code here?
    name: meta.command.token.tagged_block_predicate.mcfunction
    begin: '{{command_token_l}}{{tagged_resource_location}}(\[)'
    end: '{{lookahead_newline}}|(\])({{not_command_token_delim}}*)'
    beginCaptures:
      # TODO refactor repeated code (groups 1-4)
      1:
        # the `#`
        name: "{{name.tagged_resource_location}}"
      2:
        # the namespace
        name: "{{name.tagged_resource_location}}"
      3:
        # the `:`
        name: "{{name.tagged_resource_location}}"
      4:
        # the path
        name: "{{name.tagged_resource_location}}"
      5:
        # the opening brace
        name: "{{name.block_predicate_delims}}"
    endCaptures:
      1:
        name: "{{name.block_predicate_delims}}"
      2:
        name: "{{name.error}}"
    patterns:
      - include: "#block_predicate.arguments"

  command.token.selector_with_arguments:
    name: meta.command.token.selector_with_arguments.mcfunction

    # Begin whenever we see a base selector followed by an opening square brace.
    begin: '{{command_token_l}}{{base_selector}}(\[)'

    # Similar to quotes, we have two distinct ending cases.
    #   1. End on a newline, without consuming it. This is technically an error
    #      case, but will occur frequently with unfinished selectors; e.g. while
    #      the user is typing a selector at the end of a line.
    #   2. End on any other character, although according to the child scope it
    #      should only ever be a closing square brace. The child scope does not
    #      consume the closing brace, and so it becomes our job to check for
    #      erroneous trailing data and to advance the next token.
    end: '{{lookahead_newline}}|(\])({{not_command_token_delim}}*)'

    beginCaptures:
      1:
        name: "{{name.selector_delims}}"
      2:
        name: "{{name.selector_delims}}"

    endCaptures:
      1:
        name: "{{name.selector_delims}}"
      2:
        name: "{{name.error}}"

    patterns:
      # consume whitespace in between arguments
      - name: meta.selector.argument_spacing.mcfunction
        match: " +"
      # now the fun part: recurse yet again whenever we encounter an argument
      - name: meta.selector.argument.mcfunction

        # Begin as soon as we see a key, equals, and optional negation operator.
        begin: '{{literal}} *(\=) *(\!)? *'

        # End in three distinct cases:
        #   1. Comma followed immediately by a terminal. Consume the comma, but
        #      not the terminal. This is an error case.
        #   2. Just a comma. This is the expected case and we can proceed fine.
        #   3. just a terminal. Also an error case.
        end: '(\,)(?=[\]\n])|(\,)|(?=[\]\n])'

        beginCaptures:
          1:
            # the key
            name: "{{name.dict_key}}"
          2:
            # the `=`
            name: "{{name.selector_delims}}"
          3:
            # the optional `!`
            name: "keyword.control.mcfunction"

        endCaptures:
          1:
            # the `,` in invalid case (1)
            name: "{{name.error}}"
          2:
            # the `,` in valid case (2)
            name: "{{name.selector_delims}}"

        patterns:
          - include: "#selector.argument.resource_location"
          - include: "#selector.argument.tagged_resource_location"
          - include: "#selector.argument.range"
          - include: "#selector.argument.number"
          - include: "#selector.argument.boolean"
          - include: "#selector.argument.literal"
          - include: "#selector.argument.unquoted_string"
          - include: "#selector.argument.quoted_string"
          - include: "#selector.argument.nbt_compound"
          - include: "#selector.argument.unknown"

      # anything else apart from terminals is classified as an error
      - name: "{{name.error}}"
        match: '[^\]\n]+'

  command.token.nbt_path:
    name: meta.command.token.nbt_path.mcfunction

    # This one is tricky, because we won't know when to start recursing.
    # There's also a lot of overlap with other token types, like strings.
    # So what we're going to do is require at least one character familiar to
    # NBT paths, like dots or opening braces, immediately following a word.
    # We use lookahead here so that we can process the syntax more accurately
    # after we're more confident that the token is an NBT path.
    begin: '{{command_token_l}}(?=\w+[\.\[\{])'

    # It's impossible to know what an NBT path will end on, so apart from being
    # careful about newlines like usual we just accept anything.
    # end: '{{lookahead_newline}}|({{not_command_token_delim}}*)'
    end: "{{command_token_r}}"

    patterns:
      - include: "#nbt_path.property"

  nbt_path.property:
    patterns:
      # (Inventory)([){Count: 64}(])
      - begin: '(\.)?(\w+)(\[)'
        end: '(\])|(?=\n)'
        beginCaptures:
          1:
            name: "{{name.nbt_delims}}"
          2:
            name: "{{name.nbt_key}}"
          3:
            name: "{{name.nbt_delims}}"
        endCaptures:
          1:
            name: "{{name.nbt_delims}}"
        patterns:
          - include: "#nbt_path.index"
      # Inventory[].(tag)({)custom: true(}).display.Name
      - begin: '(\.)?(\w+)(\{)'
        end: '(\})|(?=\n)'
        beginCaptures:
          1:
            name: "{{name.nbt_delims}}"
          2:
            name: "{{name.nbt_key}}"
          3:
            name: "{{name.nbt_delims}}"
        endCaptures:
          1:
            name: "{{name.nbt_delims}}"
        patterns:
          - include: "#nbt.compound"
      # SelectedItem(.Count)
      - match: '(\.)?(\w+)'
        captures:
          1:
            name: "{{name.nbt_delims}}"
          2:
            name: "{{name.nbt_key}}"
      # (error) look-ahead double dot
      - match: '(\.)(?=\.)'
        captures:
          1:
            name: "{{name.error}}"
      # anything else between dots is an error
      # make sure to break before newlines
      - match: '[^\.\s]+'
        name: "{{name.error}}"

  nbt_path.index:
    patterns:
      # TODO this isn't really an index
      - include: "#nbt.list"

  block_predicate.arguments:
    patterns:
      - name: meta.block_predicate.argument_spacing.mcfunction
        match: " +"
      - name: meta.block_predicate.argument.mcfunction
        begin: '{{literal}} *(\=) *'
        end: '(\,)(?=[\]\n])|(\,)|(?=[\]\n])'
        beginCaptures:
          1:
            name: "{{name.dict_key}}"
          2:
            name: "{{name.block_predicate_delims}}"
        endCaptures:
          1:
            name: "{{name.error}}"
          2:
            name: "{{name.block_predicate_delims}}"
        patterns:
          - include: "#block_predicate.argument.number"
          - include: "#block_predicate.argument.boolean"
          - include: "#block_predicate.argument.literal"

  block_predicate.argument.number:
    name: meta.block_predicate.argument.number.mcfunction
    match: "{{number}}{{bpat}}"
    captures: "#number"

  block_predicate.argument.boolean:
    name: meta.block_predicate.argument.boolean.mcfunction
    match: "{{boolean}}{{bpat}}"
    captures: "#boolean"

  block_predicate.argument.literal:
    name: meta.block_predicate.argument.literal.mcfunction
    match: "{{literal}}{{bpat}}"
    captures: "#literal"

  selector.argument.resource_location:
    name: meta.selector.argument.resource_location.mcfunction
    match: "{{resource_location}}{{sat}}"
    captures: "#resource_location"

  selector.argument.tagged_resource_location:
    name: meta.selector.argument.tagged_resource_location.mcfunction
    match: "{{tagged_resource_location}}{{sat}}"
    captures: "#tagged_resource_location"

  selector.argument.range:
    name: meta.selector.argument.range.mcfunction
    match: "{{range}}{{sat}}"
    captures: "#range"

  selector.argument.number:
    name: meta.selector.argument.number.mcfunction
    match: "{{number}}{{sat}}"
    captures: "#number"

  selector.argument.boolean:
    name: meta.selector.argument.boolean.mcfunction
    match: "{{boolean}}{{sat}}"
    captures: "#boolean"

  selector.argument.literal:
    name: meta.selector.argument.literal.mcfunction
    match: "{{literal}}{{sat}}"
    captures: "#literal"

  selector.argument.unquoted_string:
    name: meta.selector.argument.unquoted_string.mcfunction
    match: "{{unquoted_string}}{{sat}}"
    captures: "#unquoted_string"

  selector.argument.quoted_string:
    name: meta.selector.argument.quoted_string.mcfunction
    begin: '(\")'
    end: '{{lookahead_newline}}|(\")([^\]\,\n]*)'
    beginCaptures:
      1:
        name: "{{name.quoted_string}}"
    endCaptures:
      1:
        name: "{{name.quoted_string}}"
      2:
        # anything trailing after the quote, apart from terminals, is an error
        name: "{{name.error}}"
    patterns:
      - include: "#common.quoted_string"

  selector.argument.nbt_compound:
    name: meta.selector.argument.nbt_compound.mcfunction
    # TODO how to differentiate between scores/advancements mapping?
    begin: '(\{)'
    end: '{{lookahead_newline}}|(\})([^\]\,\n]*)'
    beginCaptures:
      1:
        name: "{{name.nbt_delims}}"
    endCaptures:
      1:
        name: "{{name.nbt_delims}}"
      2:
        name: "{{name.error}}"
    patterns:
      - include: "#nbt.compound"

  selector.argument.unknown:
    name: meta.selector.argument.unknown.mcfunction
    match: '([^\]\n\,]+)'
    captures:
      1:
        name: "{{name.unknown}}"

  common.quoted_string:
    patterns:
      # consume everything except for backslashes, quotes, and newlines
      - name: "{{name.quoted_string}}"
        match: '[^\\\"\n]'
      # consume any escaped characters... except for newlines
      - name: "{{name.quoted_string_escape}}"
        match: '\\[^\n]'
      # consume a single backslash (implicitly followed by a newline) as an error
      - name: "{{name.error}}"
        match: '\\'
      # anything else will be handed back to the parent scope
